// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package restaking

import (
	"encoding/base64"
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_rpc "github.com/gagliardetto/solana-go/rpc"
	ag_base58 "github.com/mr-tron/base58"
	"reflect"
	"strings"
)

type FundManagerUpdatedFundEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	FundAccount      ag_solanago.PublicKey
}

var FundManagerUpdatedFundEventDataDiscriminator = [8]byte{134, 191, 120, 8, 174, 124, 129, 199}

func (obj FundManagerUpdatedFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(FundManagerUpdatedFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FundManagerUpdatedFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(FundManagerUpdatedFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[134 191 120 8 174 124 129 199]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*FundManagerUpdatedFundEventData) isEventData() {}

type FundManagerUpdatedRewardPoolEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	RewardAccount    ag_solanago.PublicKey
}

var FundManagerUpdatedRewardPoolEventDataDiscriminator = [8]byte{195, 147, 69, 56, 76, 226, 252, 128}

func (obj FundManagerUpdatedRewardPoolEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(FundManagerUpdatedRewardPoolEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `RewardAccount` param:
	err = encoder.Encode(obj.RewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FundManagerUpdatedRewardPoolEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(FundManagerUpdatedRewardPoolEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[195 147 69 56 76 226 252 128]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `RewardAccount`:
	err = decoder.Decode(&obj.RewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*FundManagerUpdatedRewardPoolEventData) isEventData() {}

type OperatorDonatedToFundEventData struct {
	ReceiptTokenMint          ag_solanago.PublicKey
	FundAccount               ag_solanago.PublicKey
	SupportedTokenMint        *ag_solanago.PublicKey `bin:"optional"`
	DonatedAmount             uint64
	DepositedAmount           uint64
	OffsettedReceivableAmount uint64
}

var OperatorDonatedToFundEventDataDiscriminator = [8]byte{87, 48, 245, 185, 4, 76, 165, 242}

func (obj OperatorDonatedToFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorDonatedToFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `DonatedAmount` param:
	err = encoder.Encode(obj.DonatedAmount)
	if err != nil {
		return err
	}
	// Serialize `DepositedAmount` param:
	err = encoder.Encode(obj.DepositedAmount)
	if err != nil {
		return err
	}
	// Serialize `OffsettedReceivableAmount` param:
	err = encoder.Encode(obj.OffsettedReceivableAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OperatorDonatedToFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorDonatedToFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[87 48 245 185 4 76 165 242]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `DonatedAmount`:
	err = decoder.Decode(&obj.DonatedAmount)
	if err != nil {
		return err
	}
	// Deserialize `DepositedAmount`:
	err = decoder.Decode(&obj.DepositedAmount)
	if err != nil {
		return err
	}
	// Deserialize `OffsettedReceivableAmount`:
	err = decoder.Decode(&obj.OffsettedReceivableAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*OperatorDonatedToFundEventData) isEventData() {}

type OperatorRanFundCommandEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	FundAccount      ag_solanago.PublicKey
	NextSequence     uint16
	NumOperated      uint64
	Command          *OperationCommand
	Result           *OperationCommandResult `bin:"optional"`
}

var OperatorRanFundCommandEventDataDiscriminator = [8]byte{10, 0, 29, 204, 128, 125, 227, 149}

func (obj OperatorRanFundCommandEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorRanFundCommandEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `NextSequence` param:
	err = encoder.Encode(obj.NextSequence)
	if err != nil {
		return err
	}
	// Serialize `NumOperated` param:
	err = encoder.Encode(obj.NumOperated)
	if err != nil {
		return err
	}
	// Serialize `Command` param:
	err = encoder.Encode(obj.Command)
	if err != nil {
		return err
	}
	// Serialize `Result` param (optional):
	{
		if obj.Result == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Result)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *OperatorRanFundCommandEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorRanFundCommandEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[10 0 29 204 128 125 227 149]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `NextSequence`:
	err = decoder.Decode(&obj.NextSequence)
	if err != nil {
		return err
	}
	// Deserialize `NumOperated`:
	err = decoder.Decode(&obj.NumOperated)
	if err != nil {
		return err
	}
	// Deserialize `Command`:
	err = decoder.Decode(&obj.Command)
	if err != nil {
		return err
	}
	// Deserialize `Result` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Result)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (*OperatorRanFundCommandEventData) isEventData() {}

type OperatorUpdatedFundPricesEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	FundAccount      ag_solanago.PublicKey
}

var OperatorUpdatedFundPricesEventDataDiscriminator = [8]byte{108, 80, 9, 116, 200, 169, 219, 220}

func (obj OperatorUpdatedFundPricesEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorUpdatedFundPricesEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OperatorUpdatedFundPricesEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorUpdatedFundPricesEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[108 80 9 116 200 169 219 220]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*OperatorUpdatedFundPricesEventData) isEventData() {}

type OperatorUpdatedNormalizedTokenPoolPricesEventData struct {
	NormalizedTokenMint        ag_solanago.PublicKey
	NormalizedTokenPoolAccount ag_solanago.PublicKey
}

var OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator = [8]byte{45, 104, 4, 51, 239, 13, 241, 0}

func (obj OperatorUpdatedNormalizedTokenPoolPricesEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `NormalizedTokenMint` param:
	err = encoder.Encode(obj.NormalizedTokenMint)
	if err != nil {
		return err
	}
	// Serialize `NormalizedTokenPoolAccount` param:
	err = encoder.Encode(obj.NormalizedTokenPoolAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OperatorUpdatedNormalizedTokenPoolPricesEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[45 104 4 51 239 13 241 0]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `NormalizedTokenMint`:
	err = decoder.Decode(&obj.NormalizedTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `NormalizedTokenPoolAccount`:
	err = decoder.Decode(&obj.NormalizedTokenPoolAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*OperatorUpdatedNormalizedTokenPoolPricesEventData) isEventData() {}

type OperatorUpdatedRewardPoolsEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	RewardAccount    ag_solanago.PublicKey
}

var OperatorUpdatedRewardPoolsEventDataDiscriminator = [8]byte{105, 173, 28, 190, 209, 115, 63, 91}

func (obj OperatorUpdatedRewardPoolsEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorUpdatedRewardPoolsEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `RewardAccount` param:
	err = encoder.Encode(obj.RewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OperatorUpdatedRewardPoolsEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorUpdatedRewardPoolsEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[105 173 28 190 209 115 63 91]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `RewardAccount`:
	err = decoder.Decode(&obj.RewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*OperatorUpdatedRewardPoolsEventData) isEventData() {}

type UserCanceledWithdrawalRequestFromFundEventData struct {
	ReceiptTokenMint            ag_solanago.PublicKey
	FundAccount                 ag_solanago.PublicKey
	SupportedTokenMint          *ag_solanago.PublicKey `bin:"optional"`
	UpdatedUserRewardAccounts   []ag_solanago.PublicKey
	User                        ag_solanago.PublicKey
	UserReceiptTokenAccount     ag_solanago.PublicKey
	UserFundAccount             ag_solanago.PublicKey
	BatchId                     uint64
	RequestId                   uint64
	RequestedReceiptTokenAmount uint64
}

var UserCanceledWithdrawalRequestFromFundEventDataDiscriminator = [8]byte{114, 97, 217, 9, 1, 121, 31, 213}

func (obj UserCanceledWithdrawalRequestFromFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserCanceledWithdrawalRequestFromFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Serialize `BatchId` param:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return err
	}
	// Serialize `RequestId` param:
	err = encoder.Encode(obj.RequestId)
	if err != nil {
		return err
	}
	// Serialize `RequestedReceiptTokenAmount` param:
	err = encoder.Encode(obj.RequestedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserCanceledWithdrawalRequestFromFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserCanceledWithdrawalRequestFromFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[114 97 217 9 1 121 31 213]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return err
	}
	// Deserialize `RequestId`:
	err = decoder.Decode(&obj.RequestId)
	if err != nil {
		return err
	}
	// Deserialize `RequestedReceiptTokenAmount`:
	err = decoder.Decode(&obj.RequestedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserCanceledWithdrawalRequestFromFundEventData) isEventData() {}

type UserCreatedOrUpdatedFundAccountEventData struct {
	ReceiptTokenMint   ag_solanago.PublicKey
	UserFundAccount    ag_solanago.PublicKey
	ReceiptTokenAmount uint64
	Created            bool
}

var UserCreatedOrUpdatedFundAccountEventDataDiscriminator = [8]byte{26, 206, 120, 214, 227, 187, 182, 0}

func (obj UserCreatedOrUpdatedFundAccountEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserCreatedOrUpdatedFundAccountEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenAmount` param:
	err = encoder.Encode(obj.ReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Serialize `Created` param:
	err = encoder.Encode(obj.Created)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserCreatedOrUpdatedFundAccountEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserCreatedOrUpdatedFundAccountEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[26 206 120 214 227 187 182 0]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Deserialize `ReceiptTokenAmount`:
	err = decoder.Decode(&obj.ReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Deserialize `Created`:
	err = decoder.Decode(&obj.Created)
	if err != nil {
		return err
	}
	return nil
}

func (*UserCreatedOrUpdatedFundAccountEventData) isEventData() {}

type UserCreatedOrUpdatedRewardAccountEventData struct {
	ReceiptTokenMint   ag_solanago.PublicKey
	UserRewardAccount  ag_solanago.PublicKey
	ReceiptTokenAmount uint64
	Created            bool
}

var UserCreatedOrUpdatedRewardAccountEventDataDiscriminator = [8]byte{41, 212, 58, 138, 122, 212, 165, 155}

func (obj UserCreatedOrUpdatedRewardAccountEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserCreatedOrUpdatedRewardAccountEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `UserRewardAccount` param:
	err = encoder.Encode(obj.UserRewardAccount)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenAmount` param:
	err = encoder.Encode(obj.ReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Serialize `Created` param:
	err = encoder.Encode(obj.Created)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserCreatedOrUpdatedRewardAccountEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserCreatedOrUpdatedRewardAccountEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[41 212 58 138 122 212 165 155]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `UserRewardAccount`:
	err = decoder.Decode(&obj.UserRewardAccount)
	if err != nil {
		return err
	}
	// Deserialize `ReceiptTokenAmount`:
	err = decoder.Decode(&obj.ReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Deserialize `Created`:
	err = decoder.Decode(&obj.Created)
	if err != nil {
		return err
	}
	return nil
}

func (*UserCreatedOrUpdatedRewardAccountEventData) isEventData() {}

type UserDepositedToFundEventData struct {
	ReceiptTokenMint          ag_solanago.PublicKey
	FundAccount               ag_solanago.PublicKey
	SupportedTokenMint        *ag_solanago.PublicKey `bin:"optional"`
	UpdatedUserRewardAccounts []ag_solanago.PublicKey
	User                      ag_solanago.PublicKey
	UserReceiptTokenAccount   ag_solanago.PublicKey
	UserFundAccount           ag_solanago.PublicKey
	UserSupportedTokenAccount *ag_solanago.PublicKey `bin:"optional"`
	WalletProvider            *string                `bin:"optional"`
	ContributionAccrualRate   *uint16                `bin:"optional"`
	DepositedAmount           uint64
	MintedReceiptTokenAmount  uint64
}

var UserDepositedToFundEventDataDiscriminator = [8]byte{254, 40, 245, 52, 68, 65, 132, 44}

func (obj UserDepositedToFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserDepositedToFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Serialize `UserSupportedTokenAccount` param (optional):
	{
		if obj.UserSupportedTokenAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.UserSupportedTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `WalletProvider` param (optional):
	{
		if obj.WalletProvider == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.WalletProvider)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `ContributionAccrualRate` param (optional):
	{
		if obj.ContributionAccrualRate == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.ContributionAccrualRate)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `DepositedAmount` param:
	err = encoder.Encode(obj.DepositedAmount)
	if err != nil {
		return err
	}
	// Serialize `MintedReceiptTokenAmount` param:
	err = encoder.Encode(obj.MintedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserDepositedToFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserDepositedToFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[254 40 245 52 68 65 132 44]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserSupportedTokenAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.UserSupportedTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `WalletProvider` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.WalletProvider)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `ContributionAccrualRate` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ContributionAccrualRate)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `DepositedAmount`:
	err = decoder.Decode(&obj.DepositedAmount)
	if err != nil {
		return err
	}
	// Deserialize `MintedReceiptTokenAmount`:
	err = decoder.Decode(&obj.MintedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserDepositedToFundEventData) isEventData() {}

type UserRequestedWithdrawalFromFundEventData struct {
	ReceiptTokenMint            ag_solanago.PublicKey
	FundAccount                 ag_solanago.PublicKey
	SupportedTokenMint          *ag_solanago.PublicKey `bin:"optional"`
	UpdatedUserRewardAccounts   []ag_solanago.PublicKey
	User                        ag_solanago.PublicKey
	UserReceiptTokenAccount     ag_solanago.PublicKey
	UserFundAccount             ag_solanago.PublicKey
	BatchId                     uint64
	RequestId                   uint64
	RequestedReceiptTokenAmount uint64
}

var UserRequestedWithdrawalFromFundEventDataDiscriminator = [8]byte{23, 105, 171, 107, 172, 40, 226, 124}

func (obj UserRequestedWithdrawalFromFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserRequestedWithdrawalFromFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Serialize `BatchId` param:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return err
	}
	// Serialize `RequestId` param:
	err = encoder.Encode(obj.RequestId)
	if err != nil {
		return err
	}
	// Serialize `RequestedReceiptTokenAmount` param:
	err = encoder.Encode(obj.RequestedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserRequestedWithdrawalFromFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserRequestedWithdrawalFromFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[23 105 171 107 172 40 226 124]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return err
	}
	// Deserialize `RequestId`:
	err = decoder.Decode(&obj.RequestId)
	if err != nil {
		return err
	}
	// Deserialize `RequestedReceiptTokenAmount`:
	err = decoder.Decode(&obj.RequestedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserRequestedWithdrawalFromFundEventData) isEventData() {}

type UserTransferredReceiptTokenEventData struct {
	ReceiptTokenMint               ag_solanago.PublicKey
	FundAccount                    ag_solanago.PublicKey
	UpdatedUserRewardAccounts      []ag_solanago.PublicKey
	Source                         ag_solanago.PublicKey
	SourceReceiptTokenAccount      ag_solanago.PublicKey
	SourceFundAccount              *ag_solanago.PublicKey `bin:"optional"`
	Destination                    ag_solanago.PublicKey
	DestinationReceiptTokenAccount ag_solanago.PublicKey
	DestinationFundAccount         *ag_solanago.PublicKey `bin:"optional"`
	TransferredReceiptTokenAmount  uint64
}

var UserTransferredReceiptTokenEventDataDiscriminator = [8]byte{50, 130, 164, 229, 182, 55, 117, 0}

func (obj UserTransferredReceiptTokenEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserTransferredReceiptTokenEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Serialize `Source` param:
	err = encoder.Encode(obj.Source)
	if err != nil {
		return err
	}
	// Serialize `SourceReceiptTokenAccount` param:
	err = encoder.Encode(obj.SourceReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `SourceFundAccount` param (optional):
	{
		if obj.SourceFundAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SourceFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Destination` param:
	err = encoder.Encode(obj.Destination)
	if err != nil {
		return err
	}
	// Serialize `DestinationReceiptTokenAccount` param:
	err = encoder.Encode(obj.DestinationReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `DestinationFundAccount` param (optional):
	{
		if obj.DestinationFundAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.DestinationFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `TransferredReceiptTokenAmount` param:
	err = encoder.Encode(obj.TransferredReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserTransferredReceiptTokenEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserTransferredReceiptTokenEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[50 130 164 229 182 55 117 0]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Deserialize `Source`:
	err = decoder.Decode(&obj.Source)
	if err != nil {
		return err
	}
	// Deserialize `SourceReceiptTokenAccount`:
	err = decoder.Decode(&obj.SourceReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `SourceFundAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SourceFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Destination`:
	err = decoder.Decode(&obj.Destination)
	if err != nil {
		return err
	}
	// Deserialize `DestinationReceiptTokenAccount`:
	err = decoder.Decode(&obj.DestinationReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `DestinationFundAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.DestinationFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `TransferredReceiptTokenAmount`:
	err = decoder.Decode(&obj.TransferredReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserTransferredReceiptTokenEventData) isEventData() {}

type UserUnwrappedReceiptTokenEventData struct {
	ReceiptTokenMint                    ag_solanago.PublicKey
	WrappedTokenMint                    ag_solanago.PublicKey
	FundAccount                         ag_solanago.PublicKey
	User                                ag_solanago.PublicKey
	UserReceiptTokenAccount             ag_solanago.PublicKey
	UserWrappedTokenAccount             ag_solanago.PublicKey
	UpdatedUserFundAccount              *ag_solanago.PublicKey `bin:"optional"`
	UpdatedUserRewardAccount            *ag_solanago.PublicKey `bin:"optional"`
	UpdatedFundWrapAccountRewardAccount ag_solanago.PublicKey
	UnwrappedReceiptTokenAmount         uint64
}

var UserUnwrappedReceiptTokenEventDataDiscriminator = [8]byte{20, 70, 209, 152, 169, 188, 70, 136}

func (obj UserUnwrappedReceiptTokenEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserUnwrappedReceiptTokenEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `WrappedTokenMint` param:
	err = encoder.Encode(obj.WrappedTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserWrappedTokenAccount` param:
	err = encoder.Encode(obj.UserWrappedTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UpdatedUserFundAccount` param (optional):
	{
		if obj.UpdatedUserFundAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.UpdatedUserFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedUserRewardAccount` param (optional):
	{
		if obj.UpdatedUserRewardAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.UpdatedUserRewardAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedFundWrapAccountRewardAccount` param:
	err = encoder.Encode(obj.UpdatedFundWrapAccountRewardAccount)
	if err != nil {
		return err
	}
	// Serialize `UnwrappedReceiptTokenAmount` param:
	err = encoder.Encode(obj.UnwrappedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserUnwrappedReceiptTokenEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserUnwrappedReceiptTokenEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[20 70 209 152 169 188 70 136]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `WrappedTokenMint`:
	err = decoder.Decode(&obj.WrappedTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserWrappedTokenAccount`:
	err = decoder.Decode(&obj.UserWrappedTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UpdatedUserFundAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.UpdatedUserFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedUserRewardAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.UpdatedUserRewardAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedFundWrapAccountRewardAccount`:
	err = decoder.Decode(&obj.UpdatedFundWrapAccountRewardAccount)
	if err != nil {
		return err
	}
	// Deserialize `UnwrappedReceiptTokenAmount`:
	err = decoder.Decode(&obj.UnwrappedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserUnwrappedReceiptTokenEventData) isEventData() {}

type UserUpdatedRewardPoolEventData struct {
	ReceiptTokenMint          ag_solanago.PublicKey
	UpdatedUserRewardAccounts []ag_solanago.PublicKey
}

var UserUpdatedRewardPoolEventDataDiscriminator = [8]byte{189, 251, 56, 47, 30, 252, 63, 27}

func (obj UserUpdatedRewardPoolEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserUpdatedRewardPoolEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserUpdatedRewardPoolEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserUpdatedRewardPoolEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[189 251 56 47 30 252 63 27]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	return nil
}

func (*UserUpdatedRewardPoolEventData) isEventData() {}

type UserWithdrewFromFundEventData struct {
	ReceiptTokenMint           ag_solanago.PublicKey
	FundAccount                ag_solanago.PublicKey
	SupportedTokenMint         *ag_solanago.PublicKey `bin:"optional"`
	User                       ag_solanago.PublicKey
	UserReceiptTokenAccount    ag_solanago.PublicKey
	UserFundAccount            ag_solanago.PublicKey
	UserSupportedTokenAccount  *ag_solanago.PublicKey `bin:"optional"`
	FundWithdrawalBatchAccount ag_solanago.PublicKey
	BatchId                    uint64
	RequestId                  uint64
	BurntReceiptTokenAmount    uint64
	ReturnedReceiptTokenAmount uint64
	WithdrawnAmount            uint64
	DeductedFeeAmount          uint64
}

var UserWithdrewFromFundEventDataDiscriminator = [8]byte{158, 87, 58, 31, 154, 207, 166, 164}

func (obj UserWithdrewFromFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserWithdrewFromFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Serialize `UserSupportedTokenAccount` param (optional):
	{
		if obj.UserSupportedTokenAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.UserSupportedTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `FundWithdrawalBatchAccount` param:
	err = encoder.Encode(obj.FundWithdrawalBatchAccount)
	if err != nil {
		return err
	}
	// Serialize `BatchId` param:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return err
	}
	// Serialize `RequestId` param:
	err = encoder.Encode(obj.RequestId)
	if err != nil {
		return err
	}
	// Serialize `BurntReceiptTokenAmount` param:
	err = encoder.Encode(obj.BurntReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Serialize `ReturnedReceiptTokenAmount` param:
	err = encoder.Encode(obj.ReturnedReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Serialize `WithdrawnAmount` param:
	err = encoder.Encode(obj.WithdrawnAmount)
	if err != nil {
		return err
	}
	// Serialize `DeductedFeeAmount` param:
	err = encoder.Encode(obj.DeductedFeeAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserWithdrewFromFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserWithdrewFromFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[158 87 58 31 154 207 166 164]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserSupportedTokenAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.UserSupportedTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `FundWithdrawalBatchAccount`:
	err = decoder.Decode(&obj.FundWithdrawalBatchAccount)
	if err != nil {
		return err
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return err
	}
	// Deserialize `RequestId`:
	err = decoder.Decode(&obj.RequestId)
	if err != nil {
		return err
	}
	// Deserialize `BurntReceiptTokenAmount`:
	err = decoder.Decode(&obj.BurntReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Deserialize `ReturnedReceiptTokenAmount`:
	err = decoder.Decode(&obj.ReturnedReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Deserialize `WithdrawnAmount`:
	err = decoder.Decode(&obj.WithdrawnAmount)
	if err != nil {
		return err
	}
	// Deserialize `DeductedFeeAmount`:
	err = decoder.Decode(&obj.DeductedFeeAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserWithdrewFromFundEventData) isEventData() {}

type UserWrappedReceiptTokenEventData struct {
	ReceiptTokenMint                    ag_solanago.PublicKey
	WrappedTokenMint                    ag_solanago.PublicKey
	FundAccount                         ag_solanago.PublicKey
	User                                ag_solanago.PublicKey
	UserReceiptTokenAccount             ag_solanago.PublicKey
	UserWrappedTokenAccount             ag_solanago.PublicKey
	UpdatedUserFundAccount              *ag_solanago.PublicKey `bin:"optional"`
	UpdatedUserRewardAccount            *ag_solanago.PublicKey `bin:"optional"`
	UpdatedFundWrapAccountRewardAccount ag_solanago.PublicKey
	WrappedReceiptTokenAmount           uint64
}

var UserWrappedReceiptTokenEventDataDiscriminator = [8]byte{24, 198, 77, 53, 129, 188, 66, 155}

func (obj UserWrappedReceiptTokenEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserWrappedReceiptTokenEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `WrappedTokenMint` param:
	err = encoder.Encode(obj.WrappedTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserWrappedTokenAccount` param:
	err = encoder.Encode(obj.UserWrappedTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UpdatedUserFundAccount` param (optional):
	{
		if obj.UpdatedUserFundAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.UpdatedUserFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedUserRewardAccount` param (optional):
	{
		if obj.UpdatedUserRewardAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.UpdatedUserRewardAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedFundWrapAccountRewardAccount` param:
	err = encoder.Encode(obj.UpdatedFundWrapAccountRewardAccount)
	if err != nil {
		return err
	}
	// Serialize `WrappedReceiptTokenAmount` param:
	err = encoder.Encode(obj.WrappedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserWrappedReceiptTokenEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserWrappedReceiptTokenEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[24 198 77 53 129 188 66 155]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `WrappedTokenMint`:
	err = decoder.Decode(&obj.WrappedTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserWrappedTokenAccount`:
	err = decoder.Decode(&obj.UserWrappedTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UpdatedUserFundAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.UpdatedUserFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedUserRewardAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.UpdatedUserRewardAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedFundWrapAccountRewardAccount`:
	err = decoder.Decode(&obj.UpdatedFundWrapAccountRewardAccount)
	if err != nil {
		return err
	}
	// Deserialize `WrappedReceiptTokenAmount`:
	err = decoder.Decode(&obj.WrappedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserWrappedReceiptTokenEventData) isEventData() {}

var eventTypes = map[[8]byte]reflect.Type{
	FundManagerUpdatedFundEventDataDiscriminator:                   reflect.TypeOf(FundManagerUpdatedFundEventData{}),
	FundManagerUpdatedRewardPoolEventDataDiscriminator:             reflect.TypeOf(FundManagerUpdatedRewardPoolEventData{}),
	OperatorDonatedToFundEventDataDiscriminator:                    reflect.TypeOf(OperatorDonatedToFundEventData{}),
	OperatorRanFundCommandEventDataDiscriminator:                   reflect.TypeOf(OperatorRanFundCommandEventData{}),
	OperatorUpdatedFundPricesEventDataDiscriminator:                reflect.TypeOf(OperatorUpdatedFundPricesEventData{}),
	OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator: reflect.TypeOf(OperatorUpdatedNormalizedTokenPoolPricesEventData{}),
	OperatorUpdatedRewardPoolsEventDataDiscriminator:               reflect.TypeOf(OperatorUpdatedRewardPoolsEventData{}),
	UserCanceledWithdrawalRequestFromFundEventDataDiscriminator:    reflect.TypeOf(UserCanceledWithdrawalRequestFromFundEventData{}),
	UserCreatedOrUpdatedFundAccountEventDataDiscriminator:          reflect.TypeOf(UserCreatedOrUpdatedFundAccountEventData{}),
	UserCreatedOrUpdatedRewardAccountEventDataDiscriminator:        reflect.TypeOf(UserCreatedOrUpdatedRewardAccountEventData{}),
	UserDepositedToFundEventDataDiscriminator:                      reflect.TypeOf(UserDepositedToFundEventData{}),
	UserRequestedWithdrawalFromFundEventDataDiscriminator:          reflect.TypeOf(UserRequestedWithdrawalFromFundEventData{}),
	UserTransferredReceiptTokenEventDataDiscriminator:              reflect.TypeOf(UserTransferredReceiptTokenEventData{}),
	UserUnwrappedReceiptTokenEventDataDiscriminator:                reflect.TypeOf(UserUnwrappedReceiptTokenEventData{}),
	UserUpdatedRewardPoolEventDataDiscriminator:                    reflect.TypeOf(UserUpdatedRewardPoolEventData{}),
	UserWithdrewFromFundEventDataDiscriminator:                     reflect.TypeOf(UserWithdrewFromFundEventData{}),
	UserWrappedReceiptTokenEventDataDiscriminator:                  reflect.TypeOf(UserWrappedReceiptTokenEventData{}),
}
var eventNames = map[[8]byte]string{
	FundManagerUpdatedFundEventDataDiscriminator:                   "FundManagerUpdatedFund",
	FundManagerUpdatedRewardPoolEventDataDiscriminator:             "FundManagerUpdatedRewardPool",
	OperatorDonatedToFundEventDataDiscriminator:                    "OperatorDonatedToFund",
	OperatorRanFundCommandEventDataDiscriminator:                   "OperatorRanFundCommand",
	OperatorUpdatedFundPricesEventDataDiscriminator:                "OperatorUpdatedFundPrices",
	OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator: "OperatorUpdatedNormalizedTokenPoolPrices",
	OperatorUpdatedRewardPoolsEventDataDiscriminator:               "OperatorUpdatedRewardPools",
	UserCanceledWithdrawalRequestFromFundEventDataDiscriminator:    "UserCanceledWithdrawalRequestFromFund",
	UserCreatedOrUpdatedFundAccountEventDataDiscriminator:          "UserCreatedOrUpdatedFundAccount",
	UserCreatedOrUpdatedRewardAccountEventDataDiscriminator:        "UserCreatedOrUpdatedRewardAccount",
	UserDepositedToFundEventDataDiscriminator:                      "UserDepositedToFund",
	UserRequestedWithdrawalFromFundEventDataDiscriminator:          "UserRequestedWithdrawalFromFund",
	UserTransferredReceiptTokenEventDataDiscriminator:              "UserTransferredReceiptToken",
	UserUnwrappedReceiptTokenEventDataDiscriminator:                "UserUnwrappedReceiptToken",
	UserUpdatedRewardPoolEventDataDiscriminator:                    "UserUpdatedRewardPool",
	UserWithdrewFromFundEventDataDiscriminator:                     "UserWithdrewFromFund",
	UserWrappedReceiptTokenEventDataDiscriminator:                  "UserWrappedReceiptToken",
}
var (
	_ *strings.Builder = nil
)
var (
	_ *base64.Encoding = nil
)
var (
	_ *ag_binary.Decoder = nil
)
var (
	_ *ag_rpc.GetTransactionResult = nil
)
var (
	_ *ag_base58.Alphabet = nil
)

type Event struct {
	Name string
	Data EventData
}

type EventData interface {
	UnmarshalWithDecoder(decoder *ag_binary.Decoder) error
	isEventData()
}

const eventLogPrefix = "Program data: "

func DecodeEvents(txData *ag_rpc.GetTransactionResult, targetProgramId ag_solanago.PublicKey, getAddressTables func(altAddresses []ag_solanago.PublicKey) (tables map[ag_solanago.PublicKey]ag_solanago.PublicKeySlice, err error)) (evts []*Event, err error) {
	var tx *ag_solanago.Transaction
	if tx, err = txData.Transaction.GetTransaction(); err != nil {
		return
	}

	altAddresses := make([]ag_solanago.PublicKey, len(tx.Message.AddressTableLookups))
	for i, alt := range tx.Message.AddressTableLookups {
		altAddresses[i] = alt.AccountKey
	}
	if len(altAddresses) > 0 {
		var tables map[ag_solanago.PublicKey]ag_solanago.PublicKeySlice
		if tables, err = getAddressTables(altAddresses); err != nil {
			return
		}
		tx.Message.SetAddressTables(tables)
		if err = tx.Message.ResolveLookups(); err != nil {
			return
		}
	}

	var base64Binaries [][]byte
	logMessageEventBinaries, err := decodeEventsFromLogMessage(txData.Meta.LogMessages)
	if err != nil {
		return
	}

	emitedCPIEventBinaries, err := decodeEventsFromEmitCPI(txData.Meta.InnerInstructions, tx.Message.AccountKeys, targetProgramId)
	if err != nil {
		return
	}

	base64Binaries = append(base64Binaries, logMessageEventBinaries...)
	base64Binaries = append(base64Binaries, emitedCPIEventBinaries...)
	evts, err = parseEvents(base64Binaries)
	return
}

func decodeEventsFromLogMessage(logMessages []string) (eventBinaries [][]byte, err error) {
	for _, log := range logMessages {
		if strings.HasPrefix(log, eventLogPrefix) {
			eventBase64 := log[len(eventLogPrefix):]

			var eventBinary []byte
			if eventBinary, err = base64.StdEncoding.DecodeString(eventBase64); err != nil {
				err = fmt.Errorf("failed to decode logMessage event: %s", eventBase64)
				return
			}
			eventBinaries = append(eventBinaries, eventBinary)
		}
	}
	return
}

func decodeEventsFromEmitCPI(InnerInstructions []ag_rpc.InnerInstruction, accountKeys ag_solanago.PublicKeySlice, targetProgramId ag_solanago.PublicKey) (eventBinaries [][]byte, err error) {
	for _, parsedIx := range InnerInstructions {
		for _, ix := range parsedIx.Instructions {
			if accountKeys[ix.ProgramIDIndex] != targetProgramId {
				continue
			}

			var ixData []byte
			if ixData, err = ag_base58.Decode(ix.Data.String()); err != nil {
				return
			}
			if len(ixData) < 8 {
				continue
			}

			eventBase64 := base64.StdEncoding.EncodeToString(ixData[8:])
			var eventBinary []byte
			if eventBinary, err = base64.StdEncoding.DecodeString(eventBase64); err != nil {
				return
			}
			eventBinaries = append(eventBinaries, eventBinary)
		}
	}
	return
}

func parseEvents(base64Binaries [][]byte) (evts []*Event, err error) {
	decoder := ag_binary.NewDecoderWithEncoding(nil, ag_binary.EncodingBorsh)

	for _, eventBinary := range base64Binaries {
		if len(eventBinary) < 8 {
			continue
		}
		eventDiscriminator := ag_binary.TypeID(eventBinary[:8])
		if eventType, ok := eventTypes[eventDiscriminator]; ok {
			eventData := reflect.New(eventType).Interface().(EventData)
			decoder.Reset(eventBinary)
			if err = eventData.UnmarshalWithDecoder(decoder); err != nil {
				err = fmt.Errorf("failed to unmarshal event %s: %w", eventType.String(), err)
				return
			}
			evts = append(evts, &Event{
				Name: eventNames[eventDiscriminator],
				Data: eventData,
			})
		}
	}
	return
}
