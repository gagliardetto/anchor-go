// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package restaking

import (
	"encoding/base64"
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_rpc "github.com/gagliardetto/solana-go/rpc"
	ag_base58 "github.com/mr-tron/base58"
	"reflect"
	"strings"
)

type FundManagerUpdatedFundEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	FundAccount      ag_solanago.PublicKey
}

var FundManagerUpdatedFundEventDataDiscriminator = [8]byte{134, 191, 120, 8, 174, 124, 129, 199}

func (obj FundManagerUpdatedFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(FundManagerUpdatedFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FundManagerUpdatedFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(FundManagerUpdatedFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[134 191 120 8 174 124 129 199]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*FundManagerUpdatedFundEventData) isEventData() {}

type FundManagerUpdatedRewardPoolEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	RewardAccount    ag_solanago.PublicKey
}

var FundManagerUpdatedRewardPoolEventDataDiscriminator = [8]byte{195, 147, 69, 56, 76, 226, 252, 128}

func (obj FundManagerUpdatedRewardPoolEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(FundManagerUpdatedRewardPoolEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `RewardAccount` param:
	err = encoder.Encode(obj.RewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FundManagerUpdatedRewardPoolEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(FundManagerUpdatedRewardPoolEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[195 147 69 56 76 226 252 128]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `RewardAccount`:
	err = decoder.Decode(&obj.RewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*FundManagerUpdatedRewardPoolEventData) isEventData() {}

type OperatorDonatedToFundEventData struct {
	ReceiptTokenMint          ag_solanago.PublicKey
	FundAccount               ag_solanago.PublicKey
	SupportedTokenMint        *ag_solanago.PublicKey `bin:"optional"`
	DonatedAmount             uint64
	DepositedAmount           uint64
	OffsettedReceivableAmount uint64
}

var OperatorDonatedToFundEventDataDiscriminator = [8]byte{87, 48, 245, 185, 4, 76, 165, 242}

func (obj OperatorDonatedToFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorDonatedToFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `DonatedAmount` param:
	err = encoder.Encode(obj.DonatedAmount)
	if err != nil {
		return err
	}
	// Serialize `DepositedAmount` param:
	err = encoder.Encode(obj.DepositedAmount)
	if err != nil {
		return err
	}
	// Serialize `OffsettedReceivableAmount` param:
	err = encoder.Encode(obj.OffsettedReceivableAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OperatorDonatedToFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorDonatedToFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[87 48 245 185 4 76 165 242]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `DonatedAmount`:
	err = decoder.Decode(&obj.DonatedAmount)
	if err != nil {
		return err
	}
	// Deserialize `DepositedAmount`:
	err = decoder.Decode(&obj.DepositedAmount)
	if err != nil {
		return err
	}
	// Deserialize `OffsettedReceivableAmount`:
	err = decoder.Decode(&obj.OffsettedReceivableAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*OperatorDonatedToFundEventData) isEventData() {}

type OperatorRanFundCommandEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	FundAccount      ag_solanago.PublicKey
	NextSequence     uint16
	NumOperated      uint64
	Command          OperationCommand
	Result           *OperationCommandResult `bin:"optional"`
}

var OperatorRanFundCommandEventDataDiscriminator = [8]byte{10, 0, 29, 204, 128, 125, 227, 149}

func (obj OperatorRanFundCommandEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorRanFundCommandEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `NextSequence` param:
	err = encoder.Encode(obj.NextSequence)
	if err != nil {
		return err
	}
	// Serialize `NumOperated` param:
	err = encoder.Encode(obj.NumOperated)
	if err != nil {
		return err
	}
	// Serialize `Command` param:
	{
		tmp := operationCommandContainer{}
		switch realvalue := obj.Command.(type) {
		case *OperationCommandInitializeTuple:
			tmp.Enum = 0
			tmp.Initialize = *realvalue
		case *OperationCommandEnqueueWithdrawalBatchTuple:
			tmp.Enum = 1
			tmp.EnqueueWithdrawalBatch = *realvalue
		case *OperationCommandClaimUnrestakedVSTTuple:
			tmp.Enum = 2
			tmp.ClaimUnrestakedVST = *realvalue
		case *OperationCommandDenormalizeNTTuple:
			tmp.Enum = 3
			tmp.DenormalizeNT = *realvalue
		case *OperationCommandUndelegateVSTTuple:
			tmp.Enum = 4
			tmp.UndelegateVST = *realvalue
		case *OperationCommandUnrestakeVRTTuple:
			tmp.Enum = 5
			tmp.UnrestakeVRT = *realvalue
		case *OperationCommandClaimUnstakedSOLTuple:
			tmp.Enum = 6
			tmp.ClaimUnstakedSOL = *realvalue
		case *OperationCommandUnstakeLSTTuple:
			tmp.Enum = 7
			tmp.UnstakeLST = *realvalue
		case *OperationCommandProcessWithdrawalBatchTuple:
			tmp.Enum = 8
			tmp.ProcessWithdrawalBatch = *realvalue
		case *OperationCommandStakeSOLTuple:
			tmp.Enum = 9
			tmp.StakeSOL = *realvalue
		case *OperationCommandNormalizeSTTuple:
			tmp.Enum = 10
			tmp.NormalizeST = *realvalue
		case *OperationCommandRestakeVSTTuple:
			tmp.Enum = 11
			tmp.RestakeVST = *realvalue
		case *OperationCommandDelegateVSTTuple:
			tmp.Enum = 12
			tmp.DelegateVST = *realvalue
		case *OperationCommandHarvestRewardTuple:
			tmp.Enum = 13
			tmp.HarvestReward = *realvalue
		}
		err := encoder.Encode(tmp)
		if err != nil {
			return err
		}
	}
	// Serialize `Result` param (optional):
	{
		if obj.Result == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Result)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *OperatorRanFundCommandEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorRanFundCommandEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[10 0 29 204 128 125 227 149]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `NextSequence`:
	err = decoder.Decode(&obj.NextSequence)
	if err != nil {
		return err
	}
	// Deserialize `NumOperated`:
	err = decoder.Decode(&obj.NumOperated)
	if err != nil {
		return err
	}
	// Deserialize `Command`:
	{
		tmp := new(operationCommandContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return err
		}
		switch tmp.Enum {
		case 0:
			obj.Command = &tmp.Initialize
		case 1:
			obj.Command = &tmp.EnqueueWithdrawalBatch
		case 2:
			obj.Command = &tmp.ClaimUnrestakedVST
		case 3:
			obj.Command = &tmp.DenormalizeNT
		case 4:
			obj.Command = &tmp.UndelegateVST
		case 5:
			obj.Command = &tmp.UnrestakeVRT
		case 6:
			obj.Command = &tmp.ClaimUnstakedSOL
		case 7:
			obj.Command = &tmp.UnstakeLST
		case 8:
			obj.Command = &tmp.ProcessWithdrawalBatch
		case 9:
			obj.Command = &tmp.StakeSOL
		case 10:
			obj.Command = &tmp.NormalizeST
		case 11:
			obj.Command = &tmp.RestakeVST
		case 12:
			obj.Command = &tmp.DelegateVST
		case 13:
			obj.Command = &tmp.HarvestReward
		default:
			return fmt.Errorf("unknown enum index: %v", tmp.Enum)
		}
	}
	// Deserialize `Result` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Result)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (*OperatorRanFundCommandEventData) isEventData() {}

type OperatorUpdatedFundPricesEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	FundAccount      ag_solanago.PublicKey
}

var OperatorUpdatedFundPricesEventDataDiscriminator = [8]byte{108, 80, 9, 116, 200, 169, 219, 220}

func (obj OperatorUpdatedFundPricesEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorUpdatedFundPricesEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OperatorUpdatedFundPricesEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorUpdatedFundPricesEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[108 80 9 116 200 169 219 220]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*OperatorUpdatedFundPricesEventData) isEventData() {}

type OperatorUpdatedNormalizedTokenPoolPricesEventData struct {
	NormalizedTokenMint        ag_solanago.PublicKey
	NormalizedTokenPoolAccount ag_solanago.PublicKey
}

var OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator = [8]byte{45, 104, 4, 51, 239, 13, 241, 0}

func (obj OperatorUpdatedNormalizedTokenPoolPricesEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `NormalizedTokenMint` param:
	err = encoder.Encode(obj.NormalizedTokenMint)
	if err != nil {
		return err
	}
	// Serialize `NormalizedTokenPoolAccount` param:
	err = encoder.Encode(obj.NormalizedTokenPoolAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OperatorUpdatedNormalizedTokenPoolPricesEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[45 104 4 51 239 13 241 0]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `NormalizedTokenMint`:
	err = decoder.Decode(&obj.NormalizedTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `NormalizedTokenPoolAccount`:
	err = decoder.Decode(&obj.NormalizedTokenPoolAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*OperatorUpdatedNormalizedTokenPoolPricesEventData) isEventData() {}

type OperatorUpdatedRewardPoolsEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	RewardAccount    ag_solanago.PublicKey
}

var OperatorUpdatedRewardPoolsEventDataDiscriminator = [8]byte{105, 173, 28, 190, 209, 115, 63, 91}

func (obj OperatorUpdatedRewardPoolsEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(OperatorUpdatedRewardPoolsEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `RewardAccount` param:
	err = encoder.Encode(obj.RewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OperatorUpdatedRewardPoolsEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(OperatorUpdatedRewardPoolsEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[105 173 28 190 209 115 63 91]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `RewardAccount`:
	err = decoder.Decode(&obj.RewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*OperatorUpdatedRewardPoolsEventData) isEventData() {}

type UserCanceledWithdrawalRequestFromFundEventData struct {
	ReceiptTokenMint            ag_solanago.PublicKey
	FundAccount                 ag_solanago.PublicKey
	SupportedTokenMint          *ag_solanago.PublicKey `bin:"optional"`
	UpdatedUserRewardAccounts   []ag_solanago.PublicKey
	User                        ag_solanago.PublicKey
	UserReceiptTokenAccount     ag_solanago.PublicKey
	UserFundAccount             ag_solanago.PublicKey
	BatchId                     uint64
	RequestId                   uint64
	RequestedReceiptTokenAmount uint64
}

var UserCanceledWithdrawalRequestFromFundEventDataDiscriminator = [8]byte{114, 97, 217, 9, 1, 121, 31, 213}

func (obj UserCanceledWithdrawalRequestFromFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserCanceledWithdrawalRequestFromFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Serialize `BatchId` param:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return err
	}
	// Serialize `RequestId` param:
	err = encoder.Encode(obj.RequestId)
	if err != nil {
		return err
	}
	// Serialize `RequestedReceiptTokenAmount` param:
	err = encoder.Encode(obj.RequestedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserCanceledWithdrawalRequestFromFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserCanceledWithdrawalRequestFromFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[114 97 217 9 1 121 31 213]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return err
	}
	// Deserialize `RequestId`:
	err = decoder.Decode(&obj.RequestId)
	if err != nil {
		return err
	}
	// Deserialize `RequestedReceiptTokenAmount`:
	err = decoder.Decode(&obj.RequestedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserCanceledWithdrawalRequestFromFundEventData) isEventData() {}

type UserCreatedOrUpdatedFundAccountEventData struct {
	ReceiptTokenMint ag_solanago.PublicKey
	UserFundAccount  ag_solanago.PublicKey
}

var UserCreatedOrUpdatedFundAccountEventDataDiscriminator = [8]byte{26, 206, 120, 214, 227, 187, 182, 0}

func (obj UserCreatedOrUpdatedFundAccountEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserCreatedOrUpdatedFundAccountEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserCreatedOrUpdatedFundAccountEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserCreatedOrUpdatedFundAccountEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[26 206 120 214 227 187 182 0]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserCreatedOrUpdatedFundAccountEventData) isEventData() {}

type UserCreatedOrUpdatedRewardAccountEventData struct {
	ReceiptTokenMint  ag_solanago.PublicKey
	UserRewardAccount ag_solanago.PublicKey
}

var UserCreatedOrUpdatedRewardAccountEventDataDiscriminator = [8]byte{41, 212, 58, 138, 122, 212, 165, 155}

func (obj UserCreatedOrUpdatedRewardAccountEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserCreatedOrUpdatedRewardAccountEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `UserRewardAccount` param:
	err = encoder.Encode(obj.UserRewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserCreatedOrUpdatedRewardAccountEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserCreatedOrUpdatedRewardAccountEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[41 212 58 138 122 212 165 155]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `UserRewardAccount`:
	err = decoder.Decode(&obj.UserRewardAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserCreatedOrUpdatedRewardAccountEventData) isEventData() {}

type UserDepositedToFundEventData struct {
	ReceiptTokenMint          ag_solanago.PublicKey
	FundAccount               ag_solanago.PublicKey
	SupportedTokenMint        *ag_solanago.PublicKey `bin:"optional"`
	UpdatedUserRewardAccounts []ag_solanago.PublicKey
	User                      ag_solanago.PublicKey
	UserReceiptTokenAccount   ag_solanago.PublicKey
	UserFundAccount           ag_solanago.PublicKey
	UserSupportedTokenAccount *ag_solanago.PublicKey `bin:"optional"`
	WalletProvider            *string                `bin:"optional"`
	ContributionAccrualRate   *uint8                 `bin:"optional"`
	DepositedAmount           uint64
	MintedReceiptTokenAmount  uint64
}

var UserDepositedToFundEventDataDiscriminator = [8]byte{254, 40, 245, 52, 68, 65, 132, 44}

func (obj UserDepositedToFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserDepositedToFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Serialize `UserSupportedTokenAccount` param (optional):
	{
		if obj.UserSupportedTokenAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.UserSupportedTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `WalletProvider` param (optional):
	{
		if obj.WalletProvider == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.WalletProvider)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `ContributionAccrualRate` param (optional):
	{
		if obj.ContributionAccrualRate == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.ContributionAccrualRate)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `DepositedAmount` param:
	err = encoder.Encode(obj.DepositedAmount)
	if err != nil {
		return err
	}
	// Serialize `MintedReceiptTokenAmount` param:
	err = encoder.Encode(obj.MintedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserDepositedToFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserDepositedToFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[254 40 245 52 68 65 132 44]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserSupportedTokenAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.UserSupportedTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `WalletProvider` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.WalletProvider)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `ContributionAccrualRate` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ContributionAccrualRate)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `DepositedAmount`:
	err = decoder.Decode(&obj.DepositedAmount)
	if err != nil {
		return err
	}
	// Deserialize `MintedReceiptTokenAmount`:
	err = decoder.Decode(&obj.MintedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserDepositedToFundEventData) isEventData() {}

type UserRequestedWithdrawalFromFundEventData struct {
	ReceiptTokenMint            ag_solanago.PublicKey
	FundAccount                 ag_solanago.PublicKey
	SupportedTokenMint          *ag_solanago.PublicKey `bin:"optional"`
	UpdatedUserRewardAccounts   []ag_solanago.PublicKey
	User                        ag_solanago.PublicKey
	UserReceiptTokenAccount     ag_solanago.PublicKey
	UserFundAccount             ag_solanago.PublicKey
	BatchId                     uint64
	RequestId                   uint64
	RequestedReceiptTokenAmount uint64
}

var UserRequestedWithdrawalFromFundEventDataDiscriminator = [8]byte{23, 105, 171, 107, 172, 40, 226, 124}

func (obj UserRequestedWithdrawalFromFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserRequestedWithdrawalFromFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Serialize `BatchId` param:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return err
	}
	// Serialize `RequestId` param:
	err = encoder.Encode(obj.RequestId)
	if err != nil {
		return err
	}
	// Serialize `RequestedReceiptTokenAmount` param:
	err = encoder.Encode(obj.RequestedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserRequestedWithdrawalFromFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserRequestedWithdrawalFromFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[23 105 171 107 172 40 226 124]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return err
	}
	// Deserialize `RequestId`:
	err = decoder.Decode(&obj.RequestId)
	if err != nil {
		return err
	}
	// Deserialize `RequestedReceiptTokenAmount`:
	err = decoder.Decode(&obj.RequestedReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserRequestedWithdrawalFromFundEventData) isEventData() {}

type UserTransferredReceiptTokenEventData struct {
	ReceiptTokenMint               ag_solanago.PublicKey
	FundAccount                    ag_solanago.PublicKey
	UpdatedUserRewardAccounts      []ag_solanago.PublicKey
	Source                         ag_solanago.PublicKey
	SourceReceiptTokenAccount      ag_solanago.PublicKey
	SourceFundAccount              *ag_solanago.PublicKey `bin:"optional"`
	Destination                    ag_solanago.PublicKey
	DestinationReceiptTokenAccount ag_solanago.PublicKey
	DestinationFundAccount         *ag_solanago.PublicKey `bin:"optional"`
	TransferredReceiptTokenAmount  uint64
}

var UserTransferredReceiptTokenEventDataDiscriminator = [8]byte{50, 130, 164, 229, 182, 55, 117, 0}

func (obj UserTransferredReceiptTokenEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserTransferredReceiptTokenEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Serialize `Source` param:
	err = encoder.Encode(obj.Source)
	if err != nil {
		return err
	}
	// Serialize `SourceReceiptTokenAccount` param:
	err = encoder.Encode(obj.SourceReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `SourceFundAccount` param (optional):
	{
		if obj.SourceFundAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SourceFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Destination` param:
	err = encoder.Encode(obj.Destination)
	if err != nil {
		return err
	}
	// Serialize `DestinationReceiptTokenAccount` param:
	err = encoder.Encode(obj.DestinationReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `DestinationFundAccount` param (optional):
	{
		if obj.DestinationFundAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.DestinationFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `TransferredReceiptTokenAmount` param:
	err = encoder.Encode(obj.TransferredReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserTransferredReceiptTokenEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserTransferredReceiptTokenEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[50 130 164 229 182 55 117 0]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	// Deserialize `Source`:
	err = decoder.Decode(&obj.Source)
	if err != nil {
		return err
	}
	// Deserialize `SourceReceiptTokenAccount`:
	err = decoder.Decode(&obj.SourceReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `SourceFundAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SourceFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Destination`:
	err = decoder.Decode(&obj.Destination)
	if err != nil {
		return err
	}
	// Deserialize `DestinationReceiptTokenAccount`:
	err = decoder.Decode(&obj.DestinationReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `DestinationFundAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.DestinationFundAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `TransferredReceiptTokenAmount`:
	err = decoder.Decode(&obj.TransferredReceiptTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserTransferredReceiptTokenEventData) isEventData() {}

type UserUpdatedRewardPoolEventData struct {
	ReceiptTokenMint          ag_solanago.PublicKey
	UpdatedUserRewardAccounts []ag_solanago.PublicKey
}

var UserUpdatedRewardPoolEventDataDiscriminator = [8]byte{189, 251, 56, 47, 30, 252, 63, 27}

func (obj UserUpdatedRewardPoolEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserUpdatedRewardPoolEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `UpdatedUserRewardAccounts` param:
	err = encoder.Encode(obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserUpdatedRewardPoolEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserUpdatedRewardPoolEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[189 251 56 47 30 252 63 27]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `UpdatedUserRewardAccounts`:
	err = decoder.Decode(&obj.UpdatedUserRewardAccounts)
	if err != nil {
		return err
	}
	return nil
}

func (*UserUpdatedRewardPoolEventData) isEventData() {}

type UserWithdrewFromFundEventData struct {
	ReceiptTokenMint           ag_solanago.PublicKey
	FundAccount                ag_solanago.PublicKey
	SupportedTokenMint         *ag_solanago.PublicKey `bin:"optional"`
	User                       ag_solanago.PublicKey
	UserReceiptTokenAccount    ag_solanago.PublicKey
	UserFundAccount            ag_solanago.PublicKey
	UserSupportedTokenAccount  *ag_solanago.PublicKey `bin:"optional"`
	FundWithdrawalBatchAccount ag_solanago.PublicKey
	BatchId                    uint64
	RequestId                  uint64
	BurntReceiptTokenAmount    uint64
	ReturnedReceiptTokenAmount uint64
	WithdrawnAmount            uint64
	DeductedFeeAmount          uint64
}

var UserWithdrewFromFundEventDataDiscriminator = [8]byte{158, 87, 58, 31, 154, 207, 166, 164}

func (obj UserWithdrewFromFundEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(UserWithdrewFromFundEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `ReceiptTokenMint` param:
	err = encoder.Encode(obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Serialize `FundAccount` param:
	err = encoder.Encode(obj.FundAccount)
	if err != nil {
		return err
	}
	// Serialize `SupportedTokenMint` param (optional):
	{
		if obj.SupportedTokenMint == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `User` param:
	err = encoder.Encode(obj.User)
	if err != nil {
		return err
	}
	// Serialize `UserReceiptTokenAccount` param:
	err = encoder.Encode(obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Serialize `UserFundAccount` param:
	err = encoder.Encode(obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Serialize `UserSupportedTokenAccount` param (optional):
	{
		if obj.UserSupportedTokenAccount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.UserSupportedTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `FundWithdrawalBatchAccount` param:
	err = encoder.Encode(obj.FundWithdrawalBatchAccount)
	if err != nil {
		return err
	}
	// Serialize `BatchId` param:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return err
	}
	// Serialize `RequestId` param:
	err = encoder.Encode(obj.RequestId)
	if err != nil {
		return err
	}
	// Serialize `BurntReceiptTokenAmount` param:
	err = encoder.Encode(obj.BurntReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Serialize `ReturnedReceiptTokenAmount` param:
	err = encoder.Encode(obj.ReturnedReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Serialize `WithdrawnAmount` param:
	err = encoder.Encode(obj.WithdrawnAmount)
	if err != nil {
		return err
	}
	// Serialize `DeductedFeeAmount` param:
	err = encoder.Encode(obj.DeductedFeeAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UserWithdrewFromFundEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(UserWithdrewFromFundEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[158 87 58 31 154 207 166 164]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `ReceiptTokenMint`:
	err = decoder.Decode(&obj.ReceiptTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `FundAccount`:
	err = decoder.Decode(&obj.FundAccount)
	if err != nil {
		return err
	}
	// Deserialize `SupportedTokenMint` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SupportedTokenMint)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `User`:
	err = decoder.Decode(&obj.User)
	if err != nil {
		return err
	}
	// Deserialize `UserReceiptTokenAccount`:
	err = decoder.Decode(&obj.UserReceiptTokenAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserFundAccount`:
	err = decoder.Decode(&obj.UserFundAccount)
	if err != nil {
		return err
	}
	// Deserialize `UserSupportedTokenAccount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.UserSupportedTokenAccount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `FundWithdrawalBatchAccount`:
	err = decoder.Decode(&obj.FundWithdrawalBatchAccount)
	if err != nil {
		return err
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return err
	}
	// Deserialize `RequestId`:
	err = decoder.Decode(&obj.RequestId)
	if err != nil {
		return err
	}
	// Deserialize `BurntReceiptTokenAmount`:
	err = decoder.Decode(&obj.BurntReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Deserialize `ReturnedReceiptTokenAmount`:
	err = decoder.Decode(&obj.ReturnedReceiptTokenAmount)
	if err != nil {
		return err
	}
	// Deserialize `WithdrawnAmount`:
	err = decoder.Decode(&obj.WithdrawnAmount)
	if err != nil {
		return err
	}
	// Deserialize `DeductedFeeAmount`:
	err = decoder.Decode(&obj.DeductedFeeAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*UserWithdrewFromFundEventData) isEventData() {}

var eventTypes = map[[8]byte]reflect.Type{
	FundManagerUpdatedFundEventDataDiscriminator:                   reflect.TypeOf(FundManagerUpdatedFundEventData{}),
	FundManagerUpdatedRewardPoolEventDataDiscriminator:             reflect.TypeOf(FundManagerUpdatedRewardPoolEventData{}),
	OperatorDonatedToFundEventDataDiscriminator:                    reflect.TypeOf(OperatorDonatedToFundEventData{}),
	OperatorRanFundCommandEventDataDiscriminator:                   reflect.TypeOf(OperatorRanFundCommandEventData{}),
	OperatorUpdatedFundPricesEventDataDiscriminator:                reflect.TypeOf(OperatorUpdatedFundPricesEventData{}),
	OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator: reflect.TypeOf(OperatorUpdatedNormalizedTokenPoolPricesEventData{}),
	OperatorUpdatedRewardPoolsEventDataDiscriminator:               reflect.TypeOf(OperatorUpdatedRewardPoolsEventData{}),
	UserCanceledWithdrawalRequestFromFundEventDataDiscriminator:    reflect.TypeOf(UserCanceledWithdrawalRequestFromFundEventData{}),
	UserCreatedOrUpdatedFundAccountEventDataDiscriminator:          reflect.TypeOf(UserCreatedOrUpdatedFundAccountEventData{}),
	UserCreatedOrUpdatedRewardAccountEventDataDiscriminator:        reflect.TypeOf(UserCreatedOrUpdatedRewardAccountEventData{}),
	UserDepositedToFundEventDataDiscriminator:                      reflect.TypeOf(UserDepositedToFundEventData{}),
	UserRequestedWithdrawalFromFundEventDataDiscriminator:          reflect.TypeOf(UserRequestedWithdrawalFromFundEventData{}),
	UserTransferredReceiptTokenEventDataDiscriminator:              reflect.TypeOf(UserTransferredReceiptTokenEventData{}),
	UserUpdatedRewardPoolEventDataDiscriminator:                    reflect.TypeOf(UserUpdatedRewardPoolEventData{}),
	UserWithdrewFromFundEventDataDiscriminator:                     reflect.TypeOf(UserWithdrewFromFundEventData{}),
}
var eventNames = map[[8]byte]string{
	FundManagerUpdatedFundEventDataDiscriminator:                   "FundManagerUpdatedFund",
	FundManagerUpdatedRewardPoolEventDataDiscriminator:             "FundManagerUpdatedRewardPool",
	OperatorDonatedToFundEventDataDiscriminator:                    "OperatorDonatedToFund",
	OperatorRanFundCommandEventDataDiscriminator:                   "OperatorRanFundCommand",
	OperatorUpdatedFundPricesEventDataDiscriminator:                "OperatorUpdatedFundPrices",
	OperatorUpdatedNormalizedTokenPoolPricesEventDataDiscriminator: "OperatorUpdatedNormalizedTokenPoolPrices",
	OperatorUpdatedRewardPoolsEventDataDiscriminator:               "OperatorUpdatedRewardPools",
	UserCanceledWithdrawalRequestFromFundEventDataDiscriminator:    "UserCanceledWithdrawalRequestFromFund",
	UserCreatedOrUpdatedFundAccountEventDataDiscriminator:          "UserCreatedOrUpdatedFundAccount",
	UserCreatedOrUpdatedRewardAccountEventDataDiscriminator:        "UserCreatedOrUpdatedRewardAccount",
	UserDepositedToFundEventDataDiscriminator:                      "UserDepositedToFund",
	UserRequestedWithdrawalFromFundEventDataDiscriminator:          "UserRequestedWithdrawalFromFund",
	UserTransferredReceiptTokenEventDataDiscriminator:              "UserTransferredReceiptToken",
	UserUpdatedRewardPoolEventDataDiscriminator:                    "UserUpdatedRewardPool",
	UserWithdrewFromFundEventDataDiscriminator:                     "UserWithdrewFromFund",
}
var (
	_ *strings.Builder = nil
)
var (
	_ *base64.Encoding = nil
)
var (
	_ *ag_binary.Decoder = nil
)
var (
	_ *ag_rpc.GetTransactionResult = nil
)
var (
	_ *ag_base58.Alphabet = nil
)

type Event struct {
	Name string
	Data EventData
}

type EventData interface {
	UnmarshalWithDecoder(decoder *ag_binary.Decoder) error
	isEventData()
}

const eventLogPrefix = "Program data: "

func DecodeEventsFromLogMessage(logMessages []string) (eventBinaries [][]byte, err error) {
	for _, log := range logMessages {
		if strings.HasPrefix(log, eventLogPrefix) {
			eventBase64 := log[len(eventLogPrefix):]

			var eventBinary []byte
			if eventBinary, err = base64.StdEncoding.DecodeString(eventBase64); err != nil {
				err = fmt.Errorf("failed to decode logMessage event: %s", eventBase64)
				return
			}
			eventBinaries = append(eventBinaries, eventBinary)
		}
	}
	return
}

func DecodeEventsFromEmitCPI(InnerInstructions []ag_rpc.InnerInstruction, accountKeys ag_solanago.PublicKeySlice, targetProgramId ag_solanago.PublicKey) (eventBinaries [][]byte, err error) {
	for _, parsedIx := range InnerInstructions {
		for _, ix := range parsedIx.Instructions {
			if accountKeys[ix.ProgramIDIndex] != targetProgramId {
				continue
			}

			var ixData []byte
			if ixData, err = ag_base58.Decode(string(ix.Data)); err != nil {
				err = fmt.Errorf("failed to decode base58 emit cpi event: %s", string(ixData))
				return
			}
			eventBase64 := base64.StdEncoding.EncodeToString(ixData[8:])
			var eventBinary []byte
			if eventBinary, err = base64.StdEncoding.DecodeString(eventBase64); err != nil {
				err = fmt.Errorf("failed to decode base64 emit cpi event: %s", eventBase64)
				return
			}
			eventBinaries = append(eventBinaries, eventBinary)
		}
	}
	return
}

func DecodeEvents(txData *ag_rpc.GetTransactionResult, targetProgramId ag_solanago.PublicKey) (evts []*Event, err error) {
	var tx *ag_solanago.Transaction
	if tx, err = txData.Transaction.GetTransaction(); err != nil {
		return
	}

	var base64Binaries [][]byte
	logMessageEventBinaries, err := DecodeEventsFromLogMessage(txData.Meta.LogMessages)
	if err != nil {
		return
	}
	emitedCPIEventBinaries, err := DecodeEventsFromEmitCPI(txData.Meta.InnerInstructions, tx.Message.AccountKeys, targetProgramId)
	if err != nil {
		return
	}

	base64Binaries = append(base64Binaries, logMessageEventBinaries...)
	base64Binaries = append(base64Binaries, emitedCPIEventBinaries...)
	evts, err = ParseEvents(base64Binaries)
	return
}

func ParseEvents(base64Binaries [][]byte) (evts []*Event, err error) {
	decoder := ag_binary.NewDecoderWithEncoding(nil, ag_binary.EncodingBorsh)

	for _, eventBinary := range base64Binaries {
		eventDiscriminator := ag_binary.TypeID(eventBinary[:8])
		if eventType, ok := eventTypes[eventDiscriminator]; ok {
			eventData := reflect.New(eventType).Interface().(EventData)
			decoder.Reset(eventBinary)
			if err = eventData.UnmarshalWithDecoder(decoder); err != nil {
				err = fmt.Errorf("failed to unmarshal event %s: %w", eventType.String(), err)
				return
			}
			evts = append(evts, &Event{
				Name: eventNames[eventDiscriminator],
				Data: eventData,
			})
		}
	}
	return
}
