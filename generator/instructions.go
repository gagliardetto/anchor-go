package generator

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/davecgh/go-spew/spew"
	"github.com/gagliardetto/anchor-go/idl"
	"github.com/gagliardetto/anchor-go/tools"
)

func (g *Generator) gen_instructions() (*OutputFile, error) {
	file := NewFile(g.options.Package)
	file.HeaderComment("Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.")
	file.HeaderComment("This file contains instructions.")
	{
		for _, instruction := range g.idl.Instructions {
			ixCode := Empty()
			{
				declarerName := newInstructionFuncName(instruction.Name)
				ixCode.Commentf("Builds a %q instruction.", instruction.Name)
				{
					if len(instruction.Docs) > 0 {
						ixCode.Line()
						// Add documentation comments for the instruction.
						for _, doc := range instruction.Docs {
							ixCode.Comment(doc)
						}
					}
				}
				ixCode.Line()
				ixCode.Func().Id(declarerName).
					Params(
						DoGroup(
							func(g *Group) {
								addCommentSections := len(instruction.Args) > 0 && len(instruction.Accounts) > 0
								if addCommentSections {
									g.Line().Comment("Params:")
								}
								g.Add(
									ListMultiline(
										func(paramsCode *Group) {
											for _, param := range instruction.Args {
												paramType := genTypeName(param.Ty)
												if IsOption(param.Ty) || IsCOption(param.Ty) {
													paramType = Op("*").Add(paramType)
												}
												paramsCode.Id(formatParamName(param.Name)).Add(paramType)
											}
										},
									),
								)
								if addCommentSections {
									g.Line().Comment("Accounts:")
								}
								g.Add(
									ListMultiline(
										func(accountsCode *Group) {
											for _, account := range instruction.Accounts {
												switch acc := account.(type) {
												case *idl.IdlInstructionAccount:
													{
														accountsCode.Id(formatAccountNameParam(acc.Name)).Qual(PkgSolanaGo, "PublicKey")
													}
													// TODO: for accounts:
													// - Optional?
													// - PDA?
													// - Address?
													// - Relations?
												case *idl.IdlInstructionAccounts:
													{
														panic(fmt.Errorf("Accounts groups are not supported yet: %s", acc.Name))
														// accs := acc.Accounts
														// // add comment for the accounts
														// if len(accs) > 0 {
														// 	accountsCode.Commentf("Accounts group %q:", acc.Name)
														// }
														// for _, acc := range accs {
														// 	// If the account has a name, use it as the parameter name.
														// 	// Otherwise, use a generic name.
														// 	acc := acc.(*idl.IdlInstructionAccount)
														// 	accountName := formatAccountNameParam(acc.Name)
														// 	accountsCode.Id(accountName).Qual(PkgSolanaGo, "PublicKey")
														// }
													}
												default:
													panic("unknown account type: " + spew.Sdump(account))
												}
											}
										},
									),
								)
							},
						),
					).
					ParamsFunc(func(returnsCode *Group) {
						returnsCode.Qual(PkgSolanaGo, "Instruction")
						returnsCode.Error()
					}).BlockFunc(
					func(body *Group) {
						if len(instruction.Args) > 0 {
							body.Id("buf__").Op(":=").New(Qual("bytes", "Buffer"))
							body.Id("enc__").Op(":=").Qual(PkgBinary, "NewBorshEncoder").Call(Id("buf__"))

							{
								// write the discriminator
								body.Line().Comment("Encode the instruction discriminator.")
								discriminatorName := FormatInstructionDiscriminatorName(instruction.Name)
								body.Err().Op(":=").Id("enc__").Dot("WriteBytes").Call(Id(discriminatorName).Index(Op(":")), False())
								body.If(Err().Op("!=").Nil()).Block(
									Return(
										Nil(),
										Qual("fmt", "Errorf").Call(Lit("failed to write instruction discriminator: %w"), Err()),
									),
								)
							}
							// for _, param := range instruction.Args {
							// 	paramName := formatParamName(param.Name)
							// 	isComplexEnum(param.Ty)

							// 	body.Line().Commentf("Encode the parameter: %s", paramName)
							// 	body.Block(
							// 		Err().Op(":=").Id("enc__").Dot("Encode").Call(Id(paramName)),
							// 		If(Err().Op("!=").Nil()).Block(
							// 			Return(
							// 				Nil(),
							// 				Qual(PkgAnchorGoErrors, "NewField").Call(
							// 					Lit(paramName),
							// 					Err(),
							// 				),
							// 			),
							// 		),
							// 	)
							// }
							checkNil := true
							body.BlockFunc(func(g *Group) {
								gen_marshal_DefinedFieldsNamed(
									g,
									instruction.Args,
									checkNil,
									func(param idl.IdlField) *Statement {
										return Id(formatParamName(param.Name))
									},
									"enc__",
									true, // returnNilErr
									func(param idl.IdlField) string {
										return formatParamName(param.Name)
									},
								)
							})
						}
						body.Id("accounts__").Op(":=").Qual(PkgSolanaGo, "AccountMetaSlice").Block()
						if len(instruction.Accounts) > 0 {
							body.Line().Comment("Add the accounts to the instruction.")

							body.Block(
								DoGroup(func(body *Group) {
									for ai, account := range instruction.Accounts {
										switch acc := account.(type) {
										case *idl.IdlInstructionAccount:
											{
												if ai > 0 {
													body.Line()
												}
												body.Comment(formatAccountCommentDocs(ai, acc))
												body.Line()
												{
													// add comment for the account
													if len(acc.Docs) > 0 {
														for _, doc := range acc.Docs {
															body.Comment(doc).Line()
														}
													}
												}
												accountName := formatAccountNameParam(acc.Name)
												body.Id("accounts__").Dot("Append").Call(
													Qual(PkgSolanaGo, "NewAccountMeta").Call(
														Id(accountName),
														Lit(acc.Writable),
														Lit(acc.Signer),
													),
												)
											}

										case *idl.IdlInstructionAccounts:
											{
												panic(fmt.Errorf("Accounts groups are not supported yet: %s", acc.Name))
												// if ai > 0 {
												// 	body.Line()
												// }
												// body.Commentf("Accounts group: %s", acc.Name)
												// body.Line()
												// accs := acc.Accounts
												// for acci, acc := range accs {
												// 	acc := acc.(*idl.IdlInstructionAccount)
												// 	body.Comment(formatAccountCommentDocs(acci, acc))
												// 	body.Line()
												// 	accountName := formatAccountNameParam(acc.Name)
												// 	body.Id("accounts__").Dot("Append").Call(
												// 		Qual(PkgSolanaGo, "NewAccountMeta").Call(
												// 			Id(accountName),
												// 			Lit(acc.Writable),
												// 			Lit(acc.Signer),
												// 		),
												// 	)
												// }
											}
										default:
											panic("unknown account type: " + spew.Sdump(account))
										}
									}
								}),
							)
						}

						// create the return instruction
						body.Line().Comment("Create the instruction.")
						body.Return(
							Qual(PkgSolanaGo, "NewInstruction").CallFunc(
								func(g *Group) {
									g.Add(
										ListMultiline(func(gg *Group) {
											gg.Id("ProgramID")
											gg.Id("accounts__")
											if len(instruction.Args) > 0 {
												gg.Id("buf__").Dot("Bytes").Call()
											} else {
												gg.Nil() // No arguments to encode.
											}
										}),
									)
								},
							),
							Nil(), // No error
						)
					})
			}
			file.Add(ixCode)
		}
	}
	return &OutputFile{
		Name: "instructions.go",
		File: file,
	}, nil
}

func formatAccountNameParam(accountName string) string {
	accountName = accountName + "Account"
	if tools.IsReservedKeyword(accountName) {
		return accountName + "_"
	}
	if !tools.IsValidIdent(accountName) {
		return "a_" + tools.ToCamelUpper(accountName)
	}
	return tools.ToCamelLower(accountName)
}

func formatParamName(paramName string) string {
	paramName = paramName + "Param"
	if tools.IsReservedKeyword(paramName) {
		return paramName + "_"
	}
	if !tools.IsValidIdent(paramName) {
		return "p_" + tools.ToCamelUpper(paramName)
	}
	return tools.ToCamelLower(paramName)
}

func newInstructionFuncName(instructionName string) string {
	return "New" + tools.ToCamelUpper(instructionName) + "Instruction"
}

func formatAccountCommentDocs(index int, account *idl.IdlInstructionAccount) string {
	buf := new(strings.Builder)
	buf.WriteString(fmt.Sprintf("Account %d %q", index, account.Name))
	buf.WriteString(": ")
	if account.Writable {
		buf.WriteString("Writable")
	} else {
		buf.WriteString("Read-only")
	}
	if account.Signer {
		buf.WriteString(", Signer")
	} else {
		buf.WriteString(", Non-signer")
	}
	if account.Optional {
		buf.WriteString(", Optional")
	} else {
		buf.WriteString(", Required")
	}
	if account.Address.IsSome() && !account.Address.Unwrap().IsZero() {
		buf.WriteString(fmt.Sprintf(", Address: %s", account.Address.Unwrap().String()))
	}
	// TODO: Handle PDA and Relations
	return buf.String()
}
