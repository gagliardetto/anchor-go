package generator

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/davecgh/go-spew/spew"
	"github.com/gagliardetto/anchor-go/idl"
	"github.com/gagliardetto/anchor-go/tools"
)

func (g *Generator) gen_instructions() (*OutputFile, error) {
	file := NewFile(g.options.Package)
	file.HeaderComment("Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.")
	file.HeaderComment("This file contains instructions and instruction parsers.")
	{
		for _, instruction := range g.idl.Instructions {
			ixCode := Empty()
			{
				declarerName := newInstructionFuncName(instruction.Name)
				ixCode.Commentf("Builds a %q instruction.", instruction.Name)
				{
					if len(instruction.Docs) > 0 {
						ixCode.Line()
						// Add documentation comments for the instruction.
						for _, doc := range instruction.Docs {
							ixCode.Comment(doc)
						}
					}
				}
				ixCode.Line()
				ixCode.Func().Id(declarerName).
					Params(
						DoGroup(
							func(g *Group) {
								addCommentSections := len(instruction.Args) > 0 && len(instruction.Accounts) > 0
								if addCommentSections {
									g.Line().Comment("Params:")
								}
								g.Add(
									ListMultiline(
										func(paramsCode *Group) {
											for _, param := range instruction.Args {
												paramType := genTypeName(param.Ty)
												if IsOption(param.Ty) || IsCOption(param.Ty) {
													paramType = Op("*").Add(paramType)
												}
												paramsCode.Id(formatParamName(param.Name)).Add(paramType)
											}
										},
									),
								)
								if addCommentSections {
									g.Line().Comment("Accounts:")
								}
								g.Add(
									ListMultiline(
										func(accountsCode *Group) {
											for _, account := range instruction.Accounts {
												switch acc := account.(type) {
												case *idl.IdlInstructionAccount:
													{
														accountsCode.Id(formatAccountNameParam(acc.Name)).Qual(PkgSolanaGo, "PublicKey")
													}
													// TODO: for accounts:
													// - Optional?
													// - PDA?
													// - Address?
													// - Relations?
												case *idl.IdlInstructionAccounts:
													{
														panic(fmt.Errorf("Accounts groups are not supported yet: %s", acc.Name))
														// accs := acc.Accounts
														// // add comment for the accounts
														// if len(accs) > 0 {
														// 	accountsCode.Commentf("Accounts group %q:", acc.Name)
														// }
														// for _, acc := range accs {
														// 	// If the account has a name, use it as the parameter name.
														// 	// Otherwise, use a generic name.
														// 	acc := acc.(*idl.IdlInstructionAccount)
														// 	accountName := formatAccountNameParam(acc.Name)
														// 	accountsCode.Id(accountName).Qual(PkgSolanaGo, "PublicKey")
														// }
													}
												default:
													panic("unknown account type: " + spew.Sdump(account))
												}
											}
										},
									),
								)
							},
						),
					).
					ParamsFunc(func(returnsCode *Group) {
						returnsCode.Qual(PkgSolanaGo, "Instruction")
						returnsCode.Error()
					}).BlockFunc(
					func(body *Group) {
						if len(instruction.Args) > 0 {
							body.Id("buf__").Op(":=").New(Qual("bytes", "Buffer"))
							body.Id("enc__").Op(":=").Qual(PkgBinary, "NewBorshEncoder").Call(Id("buf__"))

							{
								// write the discriminator
								body.Line().Comment("Encode the instruction discriminator.")
								discriminatorName := FormatInstructionDiscriminatorName(instruction.Name)
								body.Err().Op(":=").Id("enc__").Dot("WriteBytes").Call(Id(discriminatorName).Index(Op(":")), False())
								body.If(Err().Op("!=").Nil()).Block(
									Return(
										Nil(),
										Qual("fmt", "Errorf").Call(Lit("failed to write instruction discriminator: %w"), Err()),
									),
								)
							}
							// for _, param := range instruction.Args {
							// 	paramName := formatParamName(param.Name)
							// 	isComplexEnum(param.Ty)

							// 	body.Line().Commentf("Encode the parameter: %s", paramName)
							// 	body.Block(
							// 		Err().Op(":=").Id("enc__").Dot("Encode").Call(Id(paramName)),
							// 		If(Err().Op("!=").Nil()).Block(
							// 			Return(
							// 				Nil(),
							// 				Qual(PkgAnchorGoErrors, "NewField").Call(
							// 					Lit(paramName),
							// 					Err(),
							// 				),
							// 			),
							// 		),
							// 	)
							// }
							checkNil := true
							body.BlockFunc(func(g *Group) {
								gen_marshal_DefinedFieldsNamed(
									g,
									instruction.Args,
									checkNil,
									func(param idl.IdlField) *Statement {
										return Id(formatParamName(param.Name))
									},
									"enc__",
									true, // returnNilErr
									func(param idl.IdlField) string {
										return formatParamName(param.Name)
									},
								)
							})
						}
						body.Id("accounts__").Op(":=").Qual(PkgSolanaGo, "AccountMetaSlice").Block()
						if len(instruction.Accounts) > 0 {
							body.Line().Comment("Add the accounts to the instruction.")

							body.Block(
								DoGroup(func(body *Group) {
									for ai, account := range instruction.Accounts {
										switch acc := account.(type) {
										case *idl.IdlInstructionAccount:
											{
												if ai > 0 {
													body.Line()
												}
												body.Comment(formatAccountCommentDocs(ai, acc))
												body.Line()
												{
													// add comment for the account
													if len(acc.Docs) > 0 {
														for _, doc := range acc.Docs {
															body.Comment(doc).Line()
														}
													}
												}
												accountName := formatAccountNameParam(acc.Name)
												body.Id("accounts__").Dot("Append").Call(
													Qual(PkgSolanaGo, "NewAccountMeta").Call(
														Id(accountName),
														Lit(acc.Writable),
														Lit(acc.Signer),
													),
												)
											}

										case *idl.IdlInstructionAccounts:
											{
												panic(fmt.Errorf("Accounts groups are not supported yet: %s", acc.Name))
												// if ai > 0 {
												// 	body.Line()
												// }
												// body.Commentf("Accounts group: %s", acc.Name)
												// body.Line()
												// accs := acc.Accounts
												// for acci, acc := range accs {
												// 	acc := acc.(*idl.IdlInstructionAccount)
												// 	body.Comment(formatAccountCommentDocs(acci, acc))
												// 	body.Line()
												// 	accountName := formatAccountNameParam(acc.Name)
												// 	body.Id("accounts__").Dot("Append").Call(
												// 		Qual(PkgSolanaGo, "NewAccountMeta").Call(
												// 			Id(accountName),
												// 			Lit(acc.Writable),
												// 			Lit(acc.Signer),
												// 		),
												// 	)
												// }
											}
										default:
											panic("unknown account type: " + spew.Sdump(account))
										}
									}
								}),
							)
						}

						// create the return instruction
						body.Line().Comment("Create the instruction.")
						body.Return(
							Qual(PkgSolanaGo, "NewInstruction").CallFunc(
								func(g *Group) {
									g.Add(
										ListMultiline(func(gg *Group) {
											gg.Id("ProgramID")
											gg.Id("accounts__")
											if len(instruction.Args) > 0 {
												gg.Id("buf__").Dot("Bytes").Call()
											} else {
												gg.Nil() // No arguments to encode.
											}
										}),
									)
								},
							),
							Nil(), // No error
						)
					})
			}
			file.Add(ixCode)
		}
	}

	// Add instruction types and parsers
	{
		typeNames := []string{}
		discriminatorNames := []string{}
		for _, instruction := range g.idl.Instructions {
			typeNames = append(typeNames, tools.ToCamelUpper(instruction.Name)+"Instruction")
			discriminatorNames = append(discriminatorNames, tools.ToCamelUpper(instruction.Name))
		}

		// Generate instruction struct types
		{
			for _, instruction := range g.idl.Instructions {
				typeCode, err := g.gen_instructionType(instruction)
				if err != nil {
					return nil, fmt.Errorf("error generating instruction type for %s: %w", instruction.Name, err)
				}
				file.Add(typeCode)
			}
		}

		// Generate instruction parsers
		{
			code, err := g.gen_instructionParser(typeNames, discriminatorNames)
			if err != nil {
				return nil, fmt.Errorf("error generating instruction parser: %w", err)
			}
			file.Add(code)
		}
	}

	return &OutputFile{
		Name: "instructions.go",
		File: file,
	}, nil
}

func formatAccountNameParam(accountName string) string {
	accountName = accountName + "Account"
	if tools.IsReservedKeyword(accountName) {
		return accountName + "_"
	}
	if !tools.IsValidIdent(accountName) {
		return "a_" + tools.ToCamelUpper(accountName)
	}
	return tools.ToCamelLower(accountName)
}

func formatParamName(paramName string) string {
	paramName = paramName + "Param"
	if tools.IsReservedKeyword(paramName) {
		return paramName + "_"
	}
	if !tools.IsValidIdent(paramName) {
		return "p_" + tools.ToCamelUpper(paramName)
	}
	return tools.ToCamelLower(paramName)
}

func newInstructionFuncName(instructionName string) string {
	return "New" + tools.ToCamelUpper(instructionName) + "Instruction"
}

func formatAccountCommentDocs(index int, account *idl.IdlInstructionAccount) string {
	buf := new(strings.Builder)
	buf.WriteString(fmt.Sprintf("Account %d %q", index, account.Name))
	buf.WriteString(": ")
	if account.Writable {
		buf.WriteString("Writable")
	} else {
		buf.WriteString("Read-only")
	}
	if account.Signer {
		buf.WriteString(", Signer")
	} else {
		buf.WriteString(", Non-signer")
	}
	if account.Optional {
		buf.WriteString(", Optional")
	} else {
		buf.WriteString(", Required")
	}
	if account.Address.IsSome() && !account.Address.Unwrap().IsZero() {
		buf.WriteString(fmt.Sprintf(", Address: %s", account.Address.Unwrap().String()))
	}
	// TODO: Handle PDA and Relations
	return buf.String()
}

func (g *Generator) gen_instructionParser(typeNames []string, discriminatorNames []string) (Code, error) {
	code := Empty()
	{
		code.Func().Id("ParseAnyInstruction").
			Params(Id("instructionData").Index().Byte()).
			Params(Any(), Error()).
			BlockFunc(func(block *Group) {
				block.Id("decoder").Op(":=").Qual(PkgBinary, "NewBorshDecoder").Call(Id("instructionData"))
				block.List(Id("discriminator"), Err()).Op(":=").Id("decoder").Dot("ReadDiscriminator").Call()

				block.If(Err().Op("!=").Nil()).Block(
					Return(
						Nil(),
						Qual("fmt", "Errorf").Call(Lit("failed to peek instruction discriminator: %w"), Err()),
					),
				)

				block.Switch(Id("discriminator")).BlockFunc(func(switchBlock *Group) {
					for i, typeName := range typeNames {
						discriminatorName := discriminatorNames[i]
						switchBlock.Case(Id(FormatInstructionDiscriminatorName(discriminatorName))).Block(
							Id("value").Op(":=").New(Id(typeName)),
							Err().Op(":=").Id("value").Dot("UnmarshalWithDecoder").Call(Id("decoder")),
							If(Err().Op("!=").Nil()).Block(
								Return(
									Nil(),
									Qual("fmt", "Errorf").Call(Lit("failed to unmarshal instruction as "+typeName+": %w"), Err()),
								),
							),
							Return(Id("value"), Nil()),
						)
					}
					switchBlock.Default().Block(
						Return(Nil(), Qual("fmt", "Errorf").Call(Lit("unknown discriminator: %s"), Qual(PkgBinary, "FormatDiscriminator").Call(Id("discriminator")))),
					)
				})
			})
	}
	{
		code.Line().Line()
		// for each instruction, generate a function to parse it:
		for i, typeName := range typeNames {
			discriminatorName := FormatInstructionDiscriminatorName(discriminatorNames[i])

			code.Func().Id("ParseInstruction_"+typeName).
				Params(Id("instructionData").Index().Byte()).
				Params(Op("*").Id(typeName), Error()).
				BlockFunc(func(block *Group) {
					block.Id("decoder").Op(":=").Qual(PkgBinary, "NewBorshDecoder").Call(Id("instructionData"))
					block.List(Id("discriminator"), Err()).Op(":=").Id("decoder").Dot("ReadDiscriminator").Call()

					block.If(Err().Op("!=").Nil()).Block(
						Return(
							Nil(),
							Qual("fmt", "Errorf").Call(Lit("failed to peek discriminator: %w"), Err()),
						),
					)

					block.If(Id("discriminator").Op("!=").Id(discriminatorName)).Block(
						Return(Nil(), Qual("fmt", "Errorf").Call(Lit("expected discriminator %v, got %s"), Id(discriminatorName), Qual(PkgBinary, "FormatDiscriminator").Call(Id("discriminator")))),
					)

					block.Id("instruction").Op(":=").New(Id(typeName))
					block.Err().Op("=").Id("instruction").Dot("UnmarshalWithDecoder").Call(Id("decoder"))

					block.If(Err().Op("!=").Nil()).Block(
						Return(
							Nil(),
							Qual("fmt", "Errorf").Call(Lit("failed to unmarshal instruction of type "+typeName+": %w"), Err()),
						),
					)

					block.Return(Id("instruction"), Nil())
				})
			code.Line().Line()
		}
	}
	return code, nil
}

func (g *Generator) gen_instructionType(instruction idl.IdlInstruction) (Code, error) {
	code := Empty()
	typeName := tools.ToCamelUpper(instruction.Name) + "Instruction"

	// Generate the instruction struct type
	{
		code.Type().Id(typeName).StructFunc(func(structGroup *Group) {
			// Add fields for each instruction argument
			for _, arg := range instruction.Args {
				fieldType := genTypeName(arg.Ty)
				if IsOption(arg.Ty) || IsCOption(arg.Ty) {
					fieldType = Op("*").Add(fieldType)
				}
				structGroup.Id(tools.ToCamelUpper(arg.Name)).Add(fieldType).Tag(map[string]string{
					"json": arg.Name,
				})
			}
		})
	}

	// Generate UnmarshalWithDecoder method
	{
		code.Line().Line()
		code.Func().Params(Id("obj").Op("*").Id(typeName)).Id("UnmarshalWithDecoder").
			Params(Id("decoder").Op("*").Qual(PkgBinary, "Decoder")).
			Params(Error()).
			BlockFunc(func(block *Group) {
				// Note: discriminator has already been read and validated by the parser
				// Read instruction arguments
				for _, arg := range instruction.Args {
					fieldName := tools.ToCamelUpper(arg.Name)
					block.Commentf("Deserialize `%s`:", fieldName)

					if IsOption(arg.Ty) || IsCOption(arg.Ty) {
						var optionalityReaderName string
						switch {
						case IsOption(arg.Ty):
							optionalityReaderName = "ReadOption"
						case IsCOption(arg.Ty):
							optionalityReaderName = "ReadCOption"
						}

						block.BlockFunc(func(optGroup *Group) {
							optGroup.List(Id("ok"), Err()).Op(":=").Id("decoder").Dot(optionalityReaderName).Call()
							optGroup.If(Err().Op("!=").Nil()).Block(
								Return(Err()),
							)
							optGroup.If(Id("ok")).Block(
								Err().Op(":=").Id("decoder").Dot("Decode").Call(Op("&").Id("obj").Dot(fieldName)),
								If(Err().Op("!=").Nil()).Block(
									Return(Err()),
								),
							)
						})
					} else {
						block.Err().Op(":=").Id("decoder").Dot("Decode").Call(Op("&").Id("obj").Dot(fieldName))
						block.If(Err().Op("!=").Nil()).Block(
							Return(Err()),
						)
					}
				}

				block.Return(Nil())
			})
	}

	// Generate Unmarshal method
	{
		code.Line().Line()
		code.Func().Params(Id("obj").Op("*").Id(typeName)).Id("Unmarshal").
			Params(Id("buf").Index().Byte()).
			Params(Error()).
			BlockFunc(func(block *Group) {
				block.Err().Op(":=").Id("obj").Dot("UnmarshalWithDecoder").Call(
					Qual(PkgBinary, "NewBorshDecoder").Call(Id("buf")),
				)
				block.If(Err().Op("!=").Nil()).Block(
					Return(
						Qual("fmt", "Errorf").Call(
							Lit("error while unmarshaling "+typeName+": %w"),
							Err(),
						),
					),
				)
				block.Return(Nil())
			})
	}

	// Generate Unmarshal function
	{
		code.Line().Line()
		code.Func().Id("Unmarshal"+typeName).
			Params(Id("buf").Index().Byte()).
			Params(Op("*").Id(typeName), Error()).
			BlockFunc(func(block *Group) {
				block.Id("obj").Op(":=").New(Id(typeName))
				block.Err().Op(":=").Id("obj").Dot("Unmarshal").Call(Id("buf"))
				block.If(Err().Op("!=").Nil()).Block(
					Return(Nil(), Err()),
				)
				block.Return(Id("obj"), Nil())
			})
	}

	return code, nil
}
