package generator

import (
	"fmt"

	. "github.com/dave/jennifer/jen"
	"github.com/davecgh/go-spew/spew"
	"github.com/gagliardetto/anchor-go/idl"
	"github.com/gagliardetto/anchor-go/tools"
)

// genfile_types generates the file `types.go`.
func (g *Generator) genfile_types() (*OutputFile, error) {
	file := NewFile(g.options.Package)
	file.HeaderComment("Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.")
	file.HeaderComment("This file contains parsers for the types defined in the IDL.")

	{
		for index, typ := range g.idl.Types {
			code, err := g.gen_IDLTypeDef(typ)
			if err != nil {
				return nil, fmt.Errorf("error generating type %d: %w", index, err)
			}
			file.Add(code)
		}
	}

	return &OutputFile{
		Name: "types.go",
		File: file,
	}, nil
}

// `def.Type` is `IDLTypeDefTy` (which is an interface):
// either `IDLTypeDefTyEnum` or `IDLTypeDefTyStruct`.
func (g *Generator) gen_IDLTypeDef(def idl.IdlTypeDef) (Code, error) {
	switch vv := def.Ty.(type) {
	case *idl.IdlTypeDefTyStruct:
		return g.gen_IDLTypeDefTyStruct(def.Name, def.Docs, *vv, false)
	case *idl.IdlTypeDefTyEnum:
		return g.gen_IDLTypeDefTyEnum(def.Name, def.Docs, *vv)
	default:
		panic(fmt.Errorf("unhandled type: %T", vv))
	}
}

func (g *Generator) gen_IDLTypeDefTyEnum(name string, docs []string, typ idl.IdlTypeDefTyEnum) (Code, error) {
	if typ.Variants.IsAllSimple() {
		return g.gen_simpleEnum(name, docs, typ)
	}
	return g.gen_complexEnum(name, docs, typ)
}

func (g *Generator) gen_simpleEnum(name string, docs []string, typ idl.IdlTypeDefTyEnum) (Code, error) {
	st := newStatement()

	code := newStatement()
	enumTypeName := tools.ToCamelUpper(name)

	addComments(code, docs)
	{
		code.Type().Id(enumTypeName).Qual(PkgBinary, "BorshEnum")
		code.Line().Const().Parens(DoGroup(func(gr *Group) {
			for variantIndex, variant := range typ.Variants {
				// TODO: enum variants should have docs too.
				// for docIndex, doc := range variant.Docs {
				// 	if docIndex == 0 {
				// 		gr.Line()
				// 	}
				// 	gr.Comment(doc).Line()
				// }

				gr.Id(formatSimpleEnumVariantName(variant.Name, enumTypeName)).Add(func() Code {
					if variantIndex == 0 {
						return Id(enumTypeName).Op("=").Iota()
					}
					return nil
				}()).Line()
			}
			// TODO: check for fields, etc.
		}))

		// Generate stringer for the uint8 enum values:
		code.Line().Line().Func().Params(Id("value").Id(enumTypeName)).Id("String").
			Params().
			Params(String()).
			BlockFunc(func(body *Group) {
				body.Switch(Id("value")).BlockFunc(func(switchBlock *Group) {
					for _, variant := range typ.Variants {
						switchBlock.Case(Id(formatSimpleEnumVariantName(variant.Name, enumTypeName))).Line().Return(Lit(variant.Name))
					}
					switchBlock.Default().Line().Return(Lit(""))
				})
			})
		st.Add(code.Line())
	}
	return st, nil
}

func addComments(code *Statement, docs []string) {
	for _, doc := range docs {
		code.Line()
		code.Comment(doc)
	}
	if len(docs) > 0 {
		code.Line()
	}
}

func (g *Generator) gen_complexEnum(name string, docs []string, typ idl.IdlTypeDefTyEnum) (Code, error) {
	st := newStatement()

	code := newStatement()
	enumTypeName := tools.ToCamelUpper(name)

	// Add comments for the enum type:
	addComments(code, docs)
	{
		register_TypeName_as_ComplexEnum(name)
		containerName := formatEnumContainerName(enumTypeName)
		interfaceMethodName := formatInterfaceMethodName(enumTypeName)

		// Declare the interface of the enum type:
		code.Commentf("The %q interface for the %q complex enum.", interfaceMethodName, enumTypeName).Line()
		code.Type().Id(enumTypeName).Interface(
			Id(interfaceMethodName).Call(),
		).Line().Line()

		// Declare the enum variants container (non-exported, used internally)
		code.Type().Id(containerName).StructFunc(
			func(structGroup *Group) {
				structGroup.Id("Enum").Qual(PkgBinary, "BorshEnum").Tag(map[string]string{
					"bin": "enum",
				})

				for _, variant := range typ.Variants {
					structGroup.Id(tools.ToCamelUpper(variant.Name)).Id(formatComplexEnumVariantTypeName(enumTypeName, variant.Name))
				}
			},
		).Line().Line()

		// Declare parser function for the enum type:
		code.Func().Id(formatEnumParserName(enumTypeName)).Params(
			ListFunc(func(params *Group) {
				// Parameters:
				params.Id("decoder").Op("*").Qual(PkgBinary, "Decoder")
			}),
		).Params(
			ListFunc(func(results *Group) {
				// Results:
				results.Id(enumTypeName)
				results.Error()
			}),
		).
			BlockFunc(func(body *Group) {
				enumName := enumTypeName
				body.BlockFunc(func(argBody *Group) {
					argBody.List(Id("tmp")).Op(":=").New(Id(formatEnumContainerName(enumName)))

					argBody.Err().Op(":=").Id("decoder").Dot("Decode").Call(Id("tmp"))

					argBody.If(
						Err().Op("!=").Nil(),
					).Block(
						Return(
							Nil(),
							Qual("fmt", "Errorf").Call(Lit("failed parsing "+enumTypeName+": %w"), Err()),
						),
					)

					argBody.Switch(Id("tmp").Dot("Enum")).
						BlockFunc(func(switchGroup *Group) {
							interfaceType := g.idl.Types.ByName(enumName)

							for variantIndex, variant := range interfaceType.Ty.(*idl.IdlTypeDefTyEnum).Variants {
								variantTypeNameComplex := formatComplexEnumVariantTypeName(enumName, variant.Name)

								if variant.IsSimple() {
									// TODO: the actual value is not important;
									//  what's important is the type.
									switchGroup.Case(Lit(variantIndex)).
										BlockFunc(func(caseGroup *Group) {
											caseGroup.Return(
												Parens(Op("*").Id(variantTypeNameComplex)).
													Parens(Op("&").Id("tmp").Dot("Enum")),
												Nil(),
											)
										})
								} else {
									switchGroup.Case(Lit(variantIndex)).
										BlockFunc(func(caseGroup *Group) {
											caseGroup.Return(
												Op("&").Id("tmp").Dot(tools.ToCamelUpper(variant.Name)),
												Nil(),
											)
										})
								}
							}
							switchGroup.Default().
								BlockFunc(func(caseGroup *Group) {
									caseGroup.Return(
										Nil(),
										Qual("fmt", "Errorf").Call(Lit(enumTypeName+": unknown enum index: %v"), Id("tmp").Dot("Enum")),
									)
								})
						})
				})
			}).Line().Line()

		// Declare the marshaler for the enum type:
		code.Func().Id(formatEnumEncoderName(enumTypeName)).Params(
			ListFunc(func(params *Group) {
				// Parameters:
				params.Id("encoder").Op("*").Qual(PkgBinary, "Encoder")
				params.Id("value").Id(enumTypeName)
			}),
		).Params(
			ListFunc(func(results *Group) {
				// Results:
				results.Error()
			}),
		).
			BlockFunc(func(body *Group) {
				body.BlockFunc(func(argBody *Group) {
					argBody.List(Id("tmp")).Op(":=").Id(formatEnumContainerName(enumTypeName)).Block()
					argBody.Switch(Id("realvalue").Op(":=").Id("value").Op(".").Parens(Type())).
						BlockFunc(func(switchGroup *Group) {
							// TODO: maybe it's from idl.Accounts ???
							interfaceType := g.idl.Types.ByName(enumTypeName)
							for variantIndex, variant := range interfaceType.Ty.(*idl.IdlTypeDefTyEnum).Variants {
								variantTypeNameStruct := formatComplexEnumVariantTypeName(enumTypeName, variant.Name)

								switchGroup.Case(Op("*").Id(variantTypeNameStruct)).
									BlockFunc(func(caseGroup *Group) {
										caseGroup.Id("tmp").Dot("Enum").Op("=").Lit(variantIndex)
										caseGroup.Id("tmp").Dot(tools.ToCamelUpper(variant.Name)).Op("=").Op("*").Id("realvalue")
									})
							}
						})

					argBody.Return(Id("encoder").Dot("Encode").Call(Id("tmp")))
				})
			}).Line().Line()

		for _, variant := range typ.Variants {
			// Name of the variant type if the enum is a complex enum (i.e. enum variants are inline structs):
			variantTypeNameComplex := formatComplexEnumVariantTypeName(enumTypeName, variant.Name)

			// Declare the enum variant types:
			if variant.IsSimple() {
				// TODO: make the name {variantTypeName}_{interface_name} ???
				code.Type().Id(variantTypeNameComplex).Uint8().Line().Line()
			} else if variant.Fields.IsSome() {
				code.Commentf("Variant %q of enum %q", variant.Name, enumTypeName).Line()
				code.Type().Id(variantTypeNameComplex).StructFunc(
					func(structGroup *Group) {
						switch fields := variant.Fields.Unwrap().(type) {
						case idl.IdlDefinedFieldsNamed:
							for _, variantField := range fields {
								optionality := IsOption(variantField.Ty) || IsCOption(variantField.Ty)
								structGroup.Add(genField(variantField, optionality)).
									Add(func() Code {
										tagMap := map[string]string{}
										if IsOption(variantField.Ty) {
											tagMap["bin"] = "optional"
										}
										if IsCOption(variantField.Ty) {
											tagMap["bin"] = "coption"
										}
										// add json tag:
										tagMap["json"] = tools.ToCamelLower(variantField.Name) + func() string {
											if optionality {
												return ",omitempty"
											}
											return ""
										}()
										return Tag(tagMap)
									}())
							}
						case idl.IdlDefinedFieldsTuple:
							for itemIndex, tupleItem := range fields {
								optionality := IsOption(tupleItem) || IsCOption(tupleItem)
								tupleItemName := FormatTupleItemName(itemIndex)
								structGroup.Add(genFieldNamed(tupleItemName, tupleItem, optionality)).
									Add(func() Code {
										tagMap := map[string]string{}
										if IsOption(tupleItem) {
											tagMap["bin"] = "optional"
										}
										if IsCOption(tupleItem) {
											tagMap["bin"] = "coption"
										}
										// add json tag:
										tagMap["json"] = tools.ToCamelLower(tupleItemName) + func() string {
											if optionality {
												return ",omitempty"
											}
											return ""
										}()
										return Tag(tagMap)
									}())
							}
						default:
							panic("not handled: " + spew.Sdump(variant.Fields))
						}
					},
				).Line().Line()
			}

			if variant.IsSimple() {
				// Declare MarshalWithEncoder
				code.Line().Line().Func().Params(Id("obj").Id(variantTypeNameComplex)).Id("MarshalWithEncoder").
					Params(
						ListFunc(func(params *Group) {
							// Parameters:
							params.Id("encoder").Op("*").Qual(PkgBinary, "Encoder")
						}),
					).
					Params(
						ListFunc(func(results *Group) {
							// Results:
							results.Err().Error()
						}),
					).
					BlockFunc(func(body *Group) {
						body.Return(Nil())
					})
				code.Line().Line()

				// Declare UnmarshalWithDecoder
				code.Func().Params(Id("obj").Op("*").Id(variantTypeNameComplex)).Id("UnmarshalWithDecoder").
					Params(
						ListFunc(func(params *Group) {
							// Parameters:
							params.Id("decoder").Op("*").Qual(PkgBinary, "Decoder")
						}),
					).
					Params(
						ListFunc(func(results *Group) {
							// Results:
							results.Err().Error()
						}),
					).
					BlockFunc(func(body *Group) {
						body.Return(Nil())
					})
				code.Line().Line()
			} else if variant.Fields.IsSome() {
				switch fields := variant.Fields.Unwrap().(type) {
				case idl.IdlDefinedFieldsNamed:
					// Declare MarshalWithEncoder:
					code.Line().Line().Add(
						gen_MarshalWithEncoder_struct(
							g.idl,
							false,
							variantTypeNameComplex,
							"",
							fields,
							true,
						))

					// Declare UnmarshalWithDecoder
					code.Line().Line().Add(
						gen_UnmarshalWithDecoder_struct(
							g.idl,
							false,
							variantTypeNameComplex,
							"",
							fields,
						))
					code.Line().Line()
				case idl.IdlDefinedFieldsTuple:
					// TODO: handle tuples
					// Declare MarshalWithEncoder:
					code.Line().Line().Add(
						gen_MarshalWithEncoder_struct(
							g.idl,
							false,
							variantTypeNameComplex,
							"",
							fields,
							true,
						))

					// Declare UnmarshalWithDecoder
					code.Line().Line().Add(
						gen_UnmarshalWithDecoder_struct(
							g.idl,
							false,
							variantTypeNameComplex,
							"",
							fields,
						))
					code.Line().Line()
				default:
					panic("not handled: " + spew.Sdump(variant.Fields))
				}
			}

			// Declare the method to implement the parent enum interface:
			if variant.IsSimple() {
				code.Func().Params(Id("_").Op("*").Id(variantTypeNameComplex)).Id(interfaceMethodName).Params().Block().Line().Line()
			} else {
				code.Func().Params(Id("_").Op("*").Id(variantTypeNameComplex)).Id(interfaceMethodName).Params().Block().Line().Line()
			}
		}

		st.Add(code.Line().Line())
	}
	return st, nil
}
