package generator

import (
	"fmt"

	. "github.com/dave/jennifer/jen"
	"github.com/gagliardetto/anchor-go/tools"
)

func (g *Generator) genfile_events() (*OutputFile, error) {
	file := NewFile(g.options.Package)
	file.HeaderComment("Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.")
	file.HeaderComment("This file contains parsers for the events defined in the IDL.")

	names := []string{}
	{
		for _, event := range g.idl.Events {
			names = append(names, tools.ToCamelUpper(event.Name))
		}
	}
	{
		code, err := g.gen_eventParser(names)
		if err != nil {
			return nil, fmt.Errorf("error generating event parser: %w", err)
		}
		file.Add(code)
	}

	return &OutputFile{
		Name: "events.go",
		File: file,
	}, nil
}

func (g *Generator) gen_eventParser(eventNames []string) (Code, error) {
	code := Empty()
	{
		code.Func().Id("ParseAnyEvent").
			Params(Id("eventData").Index().Byte()).
			Params(Any(), Error()).
			BlockFunc(func(block *Group) {
				block.Id("decoder").Op(":=").Qual(PkgBinary, "NewBorshDecoder").Call(Id("eventData"))
				block.List(Id("discriminator"), Err()).Op(":=").Id("decoder").Dot("ReadDiscriminator").Call()

				block.If(Err().Op("!=").Nil()).Block(
					Return(
						Nil(),
						Qual("fmt", "Errorf").Call(Lit("failed to peek event discriminator: %w"), Err()),
					),
				)

				block.Switch(Id("discriminator")).BlockFunc(func(switchBlock *Group) {
					for _, name := range eventNames {
						switchBlock.Case(Id(FormatEventDiscriminatorName(name))).Block(
							Id("value").Op(":=").New(Id(name)),
							Err().Op(":=").Id("value").Dot("UnmarshalWithDecoder").Call(Id("decoder")),
							If(Err().Op("!=").Nil()).Block(
								Return(
									Nil(),
									Qual("fmt", "Errorf").Call(Lit("failed to unmarshal event as "+name+": %w"), Err()),
								),
							),
							Return(Id("value"), Nil()),
						)
					}
					switchBlock.Default().Block(
						Return(Nil(), Qual("fmt", "Errorf").Call(Lit("unknown discriminator: %s"), Qual(PkgBinary, "FormatDiscriminator").Call(Id("discriminator")))),
					)
				})
			})
	}
	{
		code.Line().Line()
		// for each event, generate a function to parse it:
		for _, name := range eventNames {
			discriminatorName := FormatEventDiscriminatorName(name)

			code.Func().Id("ParseEvent_"+name).
				Params(Id("eventData").Index().Byte()).
				Params(Op("*").Id(name), Error()).
				BlockFunc(func(block *Group) {
					block.Id("decoder").Op(":=").Qual(PkgBinary, "NewBorshDecoder").Call(Id("eventData"))
					block.List(Id("discriminator"), Err()).Op(":=").Id("decoder").Dot("ReadDiscriminator").Call()

					block.If(Err().Op("!=").Nil()).Block(
						Return(
							Nil(),
							Qual("fmt", "Errorf").Call(Lit("failed to peek discriminator: %w"), Err()),
						),
					)

					block.If(Id("discriminator").Op("!=").Id(discriminatorName)).Block(
						Return(Nil(), Qual("fmt", "Errorf").Call(Lit("expected discriminator %v, got %s"), Id(discriminatorName), Qual(PkgBinary, "FormatDiscriminator").Call(Id("discriminator")))),
					)

					block.Id("event").Op(":=").New(Id(name))
					block.Err().Op("=").Id("event").Dot("UnmarshalWithDecoder").Call(Id("decoder"))

					block.If(Err().Op("!=").Nil()).Block(
						Return(
							Nil(),
							Qual("fmt", "Errorf").Call(Lit("failed to unmarshal event of type "+name+": %w"), Err()),
						),
					)

					block.Return(Id("event"), Nil())
				})
			code.Line().Line()
		}
	}
	return code, nil
}
