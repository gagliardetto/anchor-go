package generator

import (
	"encoding/json"
	"fmt"
	"strconv"

	. "github.com/dave/jennifer/jen"
	"github.com/davecgh/go-spew/spew"
	"github.com/gagliardetto/anchor-go/idl/idltype"
	"github.com/gagliardetto/solana-go"
)

func (g *Generator) gen_constants() (*OutputFile, error) {
	file := NewFile(g.options.Package)
	file.HeaderComment("Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.")
	file.HeaderComment("This file contains constants.")
	{
		if len(g.idl.Constants) > 0 {
			file.Comment("Constants defined in the IDL:")
			file.Line()
		}
		code := Empty()
		for coi, co := range g.idl.Constants {
			if co.Name == "" {
				continue // Skip constants without a name.
			}
			if len(co.Value) == 0 {
				continue // Skip constants without a value.
			}

			addComments(code, co.Docs)

			switch ty := co.Ty.(type) {
			case *idltype.String:
				_ = ty
				// "value":"\"organism\""
				v, err := strconv.Unquote(co.Value)
				if err != nil {
					return nil, fmt.Errorf("failed to unquote string constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(v)
				code.Line()
			case *idltype.Bytes:
				_ = ty
				// "value":"[102, 101, 101, 95, 118, 97, 117, 108, 116]"
				var b []byte
				err := json.Unmarshal([]byte(co.Value), &b)
				if err != nil {
					return nil, fmt.Errorf("failed to unmarshal bytes constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Var().Id(co.Name).Op("=").Index().Byte().Op("{").ListFunc(func(byteGroup *Group) {
					for _, byteVal := range b[:] {
						byteGroup.Lit(int(byteVal))
					}
				}).Op("}")
				code.Line()
			case *idltype.Pubkey:
				_ = ty
				// "value":"MiNTdCbWwAu3boEeTL6HzS5VgLb89mhf8VhMLtMrmWL"
				pk, err := solana.PublicKeyFromBase58(co.Value)
				if err != nil {
					return nil, fmt.Errorf("failed to parse pubkey constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Var().Id(co.Name).Op("=").Qual(PkgSolanaGo, "MustPublicKeyFromBase58").Call(Lit(pk.String()))
				code.Line()
			case *idltype.Bool:
				_ = ty
				// "value":"true"
				v, err := strconv.ParseBool(co.Value)
				if err != nil {
					return nil, fmt.Errorf("failed to parse bool constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Var().Id(co.Name).Op("=").Lit(v)
				code.Line()
			case *idltype.U8:
				_ = ty
				// "value":"42"
				v, err := strconv.ParseUint(co.Value, 10, 8)
				if err != nil {
					return nil, fmt.Errorf("failed to parse u8 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(uint8(v))
				code.Line()
			case *idltype.I8:
				_ = ty
				// "value":"-42"
				v, err := strconv.ParseInt(co.Value, 10, 8)
				if err != nil {
					return nil, fmt.Errorf("failed to parse i8 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(int8(v))
				code.Line()
			case *idltype.U16:
				_ = ty
				// "value":"42"
				v, err := strconv.ParseUint(co.Value, 10, 16)
				if err != nil {
					return nil, fmt.Errorf("failed to parse u16 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(uint16(v))
				code.Line()
			case *idltype.I16:
				_ = ty
				// "value":"-42"
				v, err := strconv.ParseInt(co.Value, 10, 16)
				if err != nil {
					return nil, fmt.Errorf("failed to parse i16 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(int16(v))
				code.Line()
			case *idltype.U32:
				_ = ty
				// "value":"42"
				v, err := strconv.ParseUint(co.Value, 10, 32)
				if err != nil {
					return nil, fmt.Errorf("failed to parse u32 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(uint32(v))
				code.Line()
			case *idltype.I32:
				_ = ty
				// "value":"-42"
				v, err := strconv.ParseInt(co.Value, 10, 32)
				if err != nil {
					return nil, fmt.Errorf("failed to parse i32 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(int32(v))
				code.Line()
			case *idltype.U64:
				_ = ty
				// "value":"42"
				v, err := strconv.ParseUint(co.Value, 10, 64)
				if err != nil {
					return nil, fmt.Errorf("failed to parse u64 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(uint64(v))
				code.Line()
			case *idltype.I64:
				_ = ty
				// "value":"-42"
				v, err := strconv.ParseInt(co.Value, 10, 64)
				if err != nil {
					return nil, fmt.Errorf("failed to parse i64 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(int64(v))
				code.Line()
			case *idltype.F32:
				_ = ty
				// "value":"3.14"
				v, err := strconv.ParseFloat(co.Value, 32)
				if err != nil {
					return nil, fmt.Errorf("failed to parse f32 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(float32(v))
				code.Line()
			case *idltype.F64:
				_ = ty
				// "value":"3.14"
				// "value":"4e-6"
				v, err := strconv.ParseFloat(co.Value, 64)
				if err != nil {
					return nil, fmt.Errorf("failed to parse f64 constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				code.Const().Id(co.Name).Op("=").Lit(v)
				code.Line()
			case *idltype.Array:
				_ = ty
				// "type":{"array":["u8",23]},"value":"[115, 101, 110, 100, 95, 119, 105, 116, 104, 95, 115, 119, 97, 112, 95, 100, 101, 108, 101, 103, 97, 116, 101]"
				var b []any
				err := json.Unmarshal([]byte(co.Value), &b)
				if err != nil {
					return nil, fmt.Errorf("failed to unmarshal array constants[%d] %s: %w", coi, spew.Sdump(co), err)
				}
				size, ok := ty.Size.(*idltype.IdlArrayLenValue)
				if !ok {
					return nil, fmt.Errorf("expected IdlArrayLenValue for constants[%d] %s, got %T", coi, spew.Sdump(co), ty.Size)
				}
				if len(b) != size.Value {
					return nil, fmt.Errorf("expected %d elements in array constants[%d] %s, got %d", ty.Size, coi, spew.Sdump(co), len(b))
				}
				code.Var().Id(co.Name).Op("=").Index(Lit(size.Value)).Do(func(index *Statement) {
					switch ty.Type.(type) {
					case *idltype.U8:
						index.Byte()
					case *idltype.I8:
						index.Int8()
					case *idltype.U16:
						index.Uint16()
					case *idltype.I16:
						index.Int16()
					case *idltype.U32:
						index.Uint32()
					case *idltype.I32:
						index.Int32()
					case *idltype.U64:
						index.Uint64()
					case *idltype.I64:
						index.Int64()
					case *idltype.F32:
						index.Float32()
					case *idltype.F64:
						index.Float64()
					case *idltype.String:
						index.String()
					case *idltype.Bool:
						index.Bool()
					default:
						panic(fmt.Errorf("unsupported array type for constants[%d] %s: %T", coi, spew.Sdump(co), ty.Type))
					}
				}).Op("{").ListFunc(func(byteGroup *Group) {
					for _, val := range b[:] {
						switch ty.Type.(type) {
						case *idltype.U8:
							byteGroup.Lit(byte(val.(float64)))
						case *idltype.I8:
							byteGroup.Lit(int8(val.(float64)))
						case *idltype.U16:
							byteGroup.Lit(uint16(val.(float64)))
						case *idltype.I16:
							byteGroup.Lit(int16(val.(float64)))
						case *idltype.U32:
							byteGroup.Lit(uint32(val.(float64)))
						case *idltype.I32:
							byteGroup.Lit(int32(val.(float64)))
						case *idltype.U64:
							byteGroup.Lit(uint64(val.(float64)))
						case *idltype.I64:
							byteGroup.Lit(int64(val.(float64)))
						case *idltype.F32:
							// TODO: is this correct? Are they encoded as strings?
							v, err := strconv.ParseFloat(val.(string), 32)
							if err != nil {
								panic(fmt.Errorf("failed to parse f32 in constants[%d] %s: %w", coi, spew.Sdump(co), err))
							}
							byteGroup.Lit(float32(v))
						case *idltype.F64:
							// TODO: is this correct? Are they encoded as strings?
							v, err := strconv.ParseFloat(val.(string), 64)
							if err != nil {
								panic(fmt.Errorf("failed to parse f64 in constants[%d] %s: %w", coi, spew.Sdump(co), err))
							}
							byteGroup.Lit(v)
						case *idltype.String:
							v, err := strconv.Unquote(val.(string))
							if err != nil {
								panic(fmt.Errorf("failed to unquote string in constants[%d] %s: %w", coi, spew.Sdump(co), err))
							}
							byteGroup.Lit(v)
						case *idltype.Bool:
							v, err := strconv.ParseBool(val.(string))
							if err != nil {
								panic(fmt.Errorf("failed to parse bool in constants[%d] %s: %w", coi, spew.Sdump(co), err))
							}
							byteGroup.Lit(v)
						default:
							panic(fmt.Errorf("unsupported array type for constants[%d] %s: %T", coi, spew.Sdump(co), ty.Type))
						}
					}
				}).Op("}")
				code.Line()

			default:
				return nil, fmt.Errorf("unsupported constant type for constants[%d] %s: %T", coi, spew.Sdump(co), ty)
			}
		}
		file.Add(code)
	}
	return &OutputFile{
		Name: "constants.go",
		File: file,
	}, nil
}
